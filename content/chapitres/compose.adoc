= ğŸ‹ğŸ™ Docker compose

image::2073552164-image2.png[height=550px]

== ğŸŒğŸ¡ Un cas de la vraie vie

Une application riche repose souvent sur plusieurs Ã©lÃ©ments techniques Ã  coordonner ensemble.

(Apache, Tomcat, Node, MongoDB, ElasticSearch, Logstash, etc.)

Comment automatiser ces dÃ©ploiements ?

[%autoanimate]
== ğŸ“œğŸ’» On pourrait tout scripterâ€¦

[source,bash]
----
include::../code-samples/compose/script.sh[]
----

[%autoanimate]
== ğŸ“œğŸ’» Tout scripter

image::351794078-image3.gif[]

[%step]
- Et tout lancer indÃ©pendamment ?
- Et tout monitorer un par un ?
- Peut mieux faire, non ?

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
----
[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:

          
               
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
          
               
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----
[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
            
                
                  
  db:

----
[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
    image: "mysql:5.6"
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
    image: "mysql:5.6"
    ports:
      - "3306:3306"

----

[%auto-animate]
== ğŸ¤”â¡ï¸ Et aprÃ¨s ?

[source,bash]
----
docker compose up -d
docker compose build
docker compose logs
docker compose stop
docker compose restart
docker compose down
----

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

L'ordre de dÃ©marrage fait rÃ©fÃ©rence Ã  la sÃ©quence dans laquelle les services dÃ©finis dans un fichier Docker Compose sont lancÃ©s.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Pourquoi est-ce important ?
[%step]
Certains services peuvent dÃ©pendre d'autres services pour fonctionner correctement.
[%step]
Par exemple, une application web peut avoir besoin qu'une base de donnÃ©es soit opÃ©rationnelle avant de pouvoir dÃ©marrer.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Comment Docker Compose gÃ¨re-t-il l'ordre de dÃ©marrage ?
[%step]
Par dÃ©faut, Docker Compose dÃ©marre les services dans l'ordre dans lequel ils sont dÃ©finis dans le fichier Docker Compose.
[%step]
Cependant, cela ne garantit pas que les services dÃ©pendants seront prÃªts Ã  Ãªtre utilisÃ©s lorsque les services qui en dÃ©pendent seront lancÃ©s.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Comment gÃ©rer les dÃ©pendances entre services ?
[%step]
Docker Compose offre deux directives pour gÃ©rer les dÃ©pendances entre services : `depends_on` et `healthcheck`.

[%step]
- `depends_on` : Cette directive peut Ãªtre utilisÃ©e pour indiquer qu'un service dÃ©pend d'un autre service.
Cependant, cela ne garantit pas que le service dÃ©pendant sera prÃªt Ã  Ãªtre utilisÃ© lorsque le service qui en dÃ©pend sera lancÃ©.
- `healthcheck` : Cette directive peut Ãªtre utilisÃ©e pour vÃ©rifier l'Ã©tat de santÃ© d'un service.
En combinaison avec `depends_on`, elle peut aider Ã  s'assurer qu'un service est prÃªt Ã  Ãªtre utilisÃ© avant de lancer les services qui en dÃ©pendent.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Exemple
Voici un exemple de fichier Docker Compose qui utilise `depends_on` et `healthcheck` pour gÃ©rer l'ordre de dÃ©marrage des services :

[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 30s
      retries: 3
----

[%step]
Dans cet exemple, le service web dÃ©pend du service db.
Le service db est vÃ©rifiÃ© toutes les 30 secondes pour s'assurer qu'il est prÃªt Ã  Ãªtre utilisÃ©.
Le service web ne sera lancÃ© que lorsque le service db sera en bonne santÃ©.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrageâ“ğŸ¤” Conditions.

WARNING: Rappel:
La directive `depends_on` dans un fichier Docker Compose est utilisÃ©e pour indiquer qu'un service dÃ©pend d'un autre service.
Cela signifie que le service dÃ©pendant ne sera pas dÃ©marrÃ© tant que les services dont il dÃ©pend n'auront pas Ã©tÃ© dÃ©marrÃ©s.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrageâ“ğŸ¤” Autres conditions.

En plus de la condition service_healthy, il existe d'autres conditions que vous pouvez utiliser avec `depends_on`:
[%step]
`service_started` : Cette condition signifie que le service dÃ©pendant ne sera pas dÃ©marrÃ© tant que le service dont il dÃ©pend n'aura pas Ã©tÃ© dÃ©marrÃ©.
[%step]
`service_completed_successfully`: Cette condition indique qu'un service dÃ©pendant ne doit pas dÃ©marrer avant qu'un autre service ait terminÃ© avec succÃ¨s. Cela peut Ãªtre utile dans des scÃ©narios oÃ¹ un service doit effectuer une tÃ¢che unique qui doit Ãªtre terminÃ©e avant que d'autres services puissent dÃ©buter.
[%step]
Cependant, cela ne garantit pas que le service dont il dÃ©pend est prÃªt Ã  Ãªtre utilisÃ©.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrageâ“ğŸ¤” Autre condition.

Voici un exemple de comment vous pourriez utiliser `service_started` dans un fichier Docker Compose :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_started
  db:
    image: postgres
----

[%step]
Dans cet exemple, le service `web` ne sera dÃ©marrÃ© que lorsque le service `db` aura Ã©tÃ© dÃ©marrÃ©.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage & ğŸ©ºâœ… healthcheck

WARNING: Rappel
`healthcheck` est une instruction dans un `Dockerfile` qui permet de vÃ©rifier l'Ã©tat de santÃ© d'un service.
Il peut Ãªtre utilisÃ© pour dÃ©terminer si un service est prÃªt Ã  Ãªtre utilisÃ© ou non.
[%step]
Voici un exemple de `healthcheck` dans un `Dockerfile` :
[%step]
[source,dockerfile]
----
FROM postgres
HEALTHCHECK --interval=5m --timeout=3s \
  CMD pg_isready -U postgres || exit 1
----
[%step]
Dans cet exemple, `pg_isready -U postgres` est la commande utilisÃ©e pour vÃ©rifier l'Ã©tat de santÃ© du service.
Si cette commande rÃ©ussit, le service est considÃ©rÃ© comme sain.
Sinon, il est considÃ©rÃ© comme malsain.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage & ğŸ©ºâœ… healthcheck
WARNING: Rappel
`depends_on` est une directive dans un fichier Docker Compose qui indique qu'un service dÃ©pend d'un autre service.
Il peut Ãªtre utilisÃ© pour contrÃ´ler l'ordre de dÃ©marrage des services.
[%step]
Voici un exemple de depends_on dans un fichier Docker Compose :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
----
[%step]
Dans cet exemple, le service `web` dÃ©pend du service `db`.
Le service web ne sera dÃ©marrÃ© que lorsque le service db sera en bonne santÃ©.

[%auto-animate]
== ğŸğŸ”¢ ğŸ©ºâœ… Comment healthcheck et depends_on travaillent ensemble ?
[.title]
En combinant `healthcheck` et `depends_on`, vous pouvez contrÃ´ler l'ordre de dÃ©marrage des services en fonction de leur Ã©tat de santÃ©.
Par exemple, vous pouvez vous assurer qu'un service de base de donnÃ©es est prÃªt Ã  Ãªtre utilisÃ© avant de dÃ©marrer une application web qui en dÃ©pend.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage ğŸ“ŠğŸ“ Pour rÃ©sumer

L'ordre de dÃ©marrage fait rÃ©fÃ©rence Ã  la sÃ©quence dans laquelle les services dÃ©finis dans un fichier Docker Compose sont lancÃ©s.
Par dÃ©faut, Docker Compose dÃ©marre les services dans l'ordre dans lequel ils sont dÃ©finis dans le fichier Docker Compose.

[%step]
Docker Compose offre deux directives pour gÃ©rer les dÃ©pendances entre services : `depends_on` et `healthcheck`.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage ğŸ“ŠğŸ“ Pour rÃ©sumer

- `depends_on` : Cette directive peut Ãªtre utilisÃ©e pour indiquer qu'un service dÃ©pend d'un autre service. Elle peut Ãªtre utilisÃ©e avec deux conditions : `service_started` et `service_healthy`.
- `service_started` : Cette condition signifie que le service dÃ©pendant ne sera pas dÃ©marrÃ© tant que le service dont il dÃ©pend n'aura pas Ã©tÃ© dÃ©marrÃ©. Cependant, cela ne garantit pas que le service dont il dÃ©pend est prÃªt Ã  Ãªtre utilisÃ©.
- `service_healthy` : Cette condition est utilisÃ©e avec la directive healthcheck dans un Dockerfile pour vÃ©rifier l'Ã©tat de santÃ© d'un service. Si la commande healthcheck rÃ©ussit, Docker considÃ¨re le service comme sain. Sinon, il est considÃ©rÃ© comme malsain.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage ğŸ“ŠğŸ“ Pour rÃ©sumer
[.title]
Exemple
Voici un exemple de fichier Docker Compose qui utilise depends_on et healthcheck pour gÃ©rer l'ordre de dÃ©marrage des services :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 30s
      retries: 3
----

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

Un exemple de fichier docker-compose.yml utilisÃ© dans Jenkins:

https://raw.githubusercontent.com/ash-sxn/GSoC-2023-docker-based-quickstart/main/docker-compose.yaml

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
Les options `stdin_open: true` et `tty: true` sont utilisÃ©es pour garder l'entrÃ©e standard du conteneur ouverte et pour allouer un pseudo-TTY au conteneur, respectivement.
C'est gÃ©nÃ©ralement fait lorsque vous voulez interagir avec le service en cours d'exÃ©cution.

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----

-  La directive `entrypoint` est utilisÃ©e pour spÃ©cifier la commande qui sera exÃ©cutÃ©e lorsque le conteneur dÃ©marre.
- Dans ce cas, elle exÃ©cute une commande shell qui exÃ©cute un script nommÃ© `keygen.sh` situÃ© Ã  `/usr/local/bin/keygen.sh`.
- Le script reÃ§oit un argument `/ssh-dir`, qui est le rÃ©pertoire oÃ¹ le script effectuera ses opÃ©rations.

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
* La directive volumes est utilisÃ©e pour monter un volume nommÃ© `agent-ssh-dir` sur le chemin `/ssh-dir` Ã  l'intÃ©rieur du conteneur.
* Cela permet de conserver les donnÃ©es entre les redÃ©marrages du conteneur et peut Ã©galement Ãªtre utilisÃ© pour partager des donnÃ©es entre les conteneurs.

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
* Enfin, un healthcheck est dÃ©fini pour le service. Il s'agit d'une commande que Docker exÃ©cutera Ã  l'intÃ©rieur du conteneur pour vÃ©rifier sa santÃ©.
* Dans ce cas, la commande vÃ©rifie si un fichier nommÃ© `conductor_ok` existe dans le rÃ©pertoire `/ssh-dir`.
* Si le fichier existe, la commande rÃ©ussit et Docker considÃ¨re le service comme sain.
* Si le fichier n'existe pas, la commande Ã©choue et Docker considÃ¨re le service comme malsain.
* Docker exÃ©cutera cette vÃ©rification de santÃ© toutes les 5 secondes (`interval: 5s`), et si elle ne rÃ©pond pas dans les 10 secondes (`timeout: 10s`), Docker la considÃ©rera comme un Ã©chec. Docker rÃ©essaiera une vÃ©rification de santÃ© Ã©chouÃ©e 5 fois (`retries: 5`) avant de considÃ©rer le service comme malsain.

[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
* Service jenkins_controller
[%step]
** Ce service dÃ©pend du `sidekick_service`.
** Il ne dÃ©marrera que lorsque le `sidekick_service` aura terminÃ© avec succÃ¨s.
** C'est ce que signifie la condition `service_completed_successfully`.
--


[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Un `healthcheck` est Ã©galement dÃ©fini pour ce service.
[%step]
* Docker vÃ©rifie si un fichier nommÃ© `conductor_ok` existe dans le chemin `/ssh-dir`.
* Si le fichier existe, Docker considÃ¨re le service comme sain.
* Sinon, il est considÃ©rÃ© comme malsain.
--


[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Service `default_agent`
[%step]
* Ce service dÃ©pend Ã©galement du `sidekick_service` et du `jenkins_controller`.
* Il ne dÃ©marrera que lorsque le `sidekick_service` aura terminÃ© avec succÃ¨s et que le `jenkins_controller` aura dÃ©marrÃ©.
* C'est ce que signifient les conditions `service_completed_successfully` et `service_started`.
--

[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Un `healthcheck` est Ã©galement dÃ©fini pour ce service.
[%step]
* Docker vÃ©rifie si un fichier nommÃ© `authorized_keys` existe dans le chemin `/home/jenkins/.ssh`.
* Si le fichier existe, Docker considÃ¨re le service comme sain.
* Sinon, il est considÃ©rÃ© comme malsain.
--

[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Enfin, un volume nommÃ© `agent-ssh-dir` est montÃ© sur le chemin `/home/jenkins/.ssh` Ã  l'intÃ©rieur du conteneur en lecture seule.
--

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

Ã€ Ã©tudier au calme chez vous:

https://raw.githubusercontent.com/gounthar/MyFirstAndroidAppBuiltByJenkins/stf/jenkins/docker-compose.yml

image::47642838-image4.png[]

[.notes]
--
Dans le temps, on recommandait de faire un script qui attendait que le service soit dÃ©marrÃ© avant de continuer.
https://github.com/vishnubob/wait-for-it
--

== Transformer son application en docker compose

Deux approches diffÃ©rentes et complÃ©mentairesÂ :
[%step]
* https://www.composerize.com/
* https://github.com/jwilder/dockerize

== Travaux pratiques #12

image::497269344-image5.png[]

https://gitlab.univ-artois.fr/bruno.verachten/devops-docker-tp12.git

