= R√©seaux et Docker

[.title]
Interagir avec le Docker ENGINE

image::2375.png[]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output2_with_transparency.png[height=600]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output3_with_transparency.png[height=600]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output4_with_transparency.png[height=600]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output5_with_transparency.png[height=600]

[.notes]
--
La communication d'un navigateur avec le moteur Docker sur le port 2375 peut se faire via l'API Docker expos√©e sur ce port. Voici comment cela fonctionne :

Exposer l'API Docker sur le port 2375 : Tout d'abord, pour permettre la communication du navigateur avec le moteur Docker, vous devez vous assurer que l'API Docker est expos√©e sur le port 2375. Vous pouvez sp√©cifier cela lors de la configuration du moteur Docker. Par exemple, en utilisant l'option -H :

[source,bash]
----
dockerd -H tcp://0.0.0.0:2375
----
Cela signifie que le moteur Docker √©coutera les requ√™tes sur le port 2375.

Utilisation de l'API Docker : Une fois que l'API Docker est expos√©e, vous pouvez effectuer des op√©rations Docker en utilisant des requ√™tes HTTP. Le navigateur peut envoyer des requ√™tes HTTP directement √† l'adresse IP du serveur Docker et au port 2375.

Par exemple, pour lister les conteneurs en cours d'ex√©cution, vous pouvez utiliser une requ√™te HTTP GET :

[source,http]
----
GET http://adresse_ip_du_serveur_docker:2375/containers/json
----
Le serveur Docker r√©pondra avec les d√©tails des conteneurs en cours d'ex√©cution au format JSON.

S√©curit√© : Il est important de noter que l'exposition de l'API Docker sur un port non s√©curis√© peut pr√©senter des risques de s√©curit√©, car n'importe qui avec acc√®s au port 2375 peut potentiellement contr√¥ler le moteur Docker. Pour des raisons de s√©curit√©, il est recommand√© de limiter l'acc√®s √† l'API Docker en utilisant des m√©canismes d'authentification, d'autorisation et de chiffrement.

Outils tiers : En pratique, les navigateurs ne sont pas souvent utilis√©s pour interagir directement avec l'API Docker. Au lieu de cela, des outils tiers, des biblioth√®ques ou des clients Docker sont souvent utilis√©s pour simplifier les op√©rations Docker et fournir une couche de s√©curit√© suppl√©mentaire.
--

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output6_with_transparency.png[height=600]

[.notes]
--
[source,bash]
----
for i in {2..6}; do convert Diapositive${i}.PNG -crop 9004x5341+1968+1654 -transparent white -resize x1080 reseaux-output${i}_with_transparency.png; done
----

--

[.intellij.background]
== Ex : int√©gration IntelliJ

image::intellij-docker.png[background, size=cover, position=left, opacity=0.1]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

Sauf que...

image::reseaux-docker-desktop-2375-configuration.png[width=600]

[.notes]
--
Par d√©faut, les installations de Docker n'ouvrent plus le port 2375 comme c'√©tait le cas avant. C'est toutefois changeable dans le Docker Desktop.
--

== Les r√©seaux de containers

image::1435904594-image8.png[]

[%auto-animate]
== üó∫Ô∏èüîÄ Mapping de Port : Rappel

[source,bash]
----
docker container run ‚Äìd -p 8000:80 nginx
----

[%auto-animate]
== üó∫Ô∏èüîÄ Mapping de Port : Rappel

image::reseaux-output11_with_transparency.png[]

[%auto-animate]
== üó∫Ô∏èüîÄ Mapping de Port : Rappel

image::reseaux-output12_with_transparency.png[]

[%step]
[source,bash]
----
curl -I --noproxy '*' http://172.17.0.2:80
It works!
----

[%step]
[source,bash]
----
curl -I --noproxy '*' http://localhost:8000
It works too!
----

[.notes]
--
[source,bash]
----
for i in {11..12}; do convert Diapositive${i}.PNG -crop 8833x2599+2250+1833 -transparent white -resize x1080 reseaux-output${i}_with_transparency.png; done
----
--

[%auto-animate]
== üåê Les r√©seaux

[source,bash]
----
docker network ls
----

[%step]
[source,bash]
----
NETWORK ID     NAME                                                             DRIVER    SCOPE
11b7af7b16e4   bridge                                                           bridge    local
1112832d205b   cours-devops-docker_default                                      bridge    local
7ab15cc28199   docker_volumes-backup-extension-desktop-extension_default        bridge    local
34caf4674478   host                                                             host      local
2a179c7be3b3   none                                                             null      local
0c577a792771   portainer_portainer-docker-extension-desktop-extension_default   bridge    local
----

[%step]
image::les_r√©seaux.png[]

[.notes]
--
Dans le contexte de la commande "docker network ls", la colonne "DRIVER" (pilote) fait r√©f√©rence au pilote r√©seau utilis√© pour cr√©er le r√©seau Docker. Voici quelques explications concernant les valeurs possibles de cette colonne :

1. **Local (bridge)** : Un r√©seau avec une port√©e "local" est g√©n√©ralement un r√©seau de pont (bridge).
Il n'est accessible qu'√† l'int√©rieur de l'h√¥te Docker o√π il a √©t√© cr√©√©.
Les conteneurs connect√©s au m√™me r√©seau local peuvent communiquer entre eux, mais ce r√©seau est isol√© des autres h√¥tes Docker ou r√©seaux externes.
2. **Host (h√¥te)** : Un r√©seau avec une port√©e "host" n'offre aucune isolation r√©seau, ce qui signifie qu'il est accessible depuis l'h√¥te o√π Docker est en cours d'ex√©cution.
Les conteneurs sur ce r√©seau partagent la pile r√©seau de l'h√¥te et peuvent acc√©der directement aux ressources de l'h√¥te.
3. **Null (null)** : Un r√©seau avec une port√©e "null" est un type de r√©seau qui ne fournit aucune connectivit√©.
C'est essentiellement un r√©seau sans port√©e, et il est utilis√© pour les conteneurs qui n'ont pas besoin d'un acc√®s r√©seau.

D'autres pilotes de r√©seau peuvent √©galement √™tre disponibles, en fonction de la configuration de Docker et des plugins install√©s.
Chaque pilote offre des fonctionnalit√©s et des options de configuration sp√©cifiques pour r√©pondre aux besoins de divers cas d'utilisation.

La colonne "DRIVER" vous permet de comprendre quel pilote r√©seau est associ√© √† chaque r√©seau Docker et comment il fonctionne.
Elle joue un r√¥le essentiel dans la d√©finition de la mani√®re dont les conteneurs communiquent entre eux et avec le r√©seau externe.
--


[%auto-animate]
== üåê Les r√©seaux

[source,bash]
----
docker network ls
----

[source,bash]
----
NETWORK ID     NAME                                                             DRIVER    SCOPE
11b7af7b16e4   bridge                                                           bridge    local
1112832d205b   cours-devops-docker_default                                      bridge    local
7ab15cc28199   docker_volumes-backup-extension-desktop-extension_default        bridge    local
34caf4674478   host                                                             host      local
2a179c7be3b3   none                                                             null      local
0c577a792771   portainer_portainer-docker-extension-desktop-extension_default   bridge    local
----

image::les_r√©seaux.png[]

[.notes]
--
Le terme "SCOPE" dans le contexte de "docker network ls" se r√©f√®re au domaine de validit√© du r√©seau Docker. Voici une explication en fran√ßais :

1. **Local** : Lorsque vous voyez "local" dans la colonne "SCOPE", cela signifie que le r√©seau Docker a une port√©e locale.
Les r√©seaux ayant une port√©e locale sont accessibles uniquement sur l'h√¥te o√π ils ont √©t√© cr√©√©s.
Les conteneurs sur cet h√¥te peuvent se connecter au r√©seau, mais ils ne peuvent pas le faire depuis d'autres h√¥tes.
2. **Global** : En revanche, si vous voyez "global" dans la colonne "SCOPE", cela signifie que le r√©seau Docker a une port√©e globale.
Cela permet aux conteneurs de se connecter √† ce r√©seau depuis d'autres h√¥tes de votre environnement Docker.

Ainsi, la valeur "SCOPE" vous indique si un r√©seau Docker est limit√© √† un seul h√¥te (port√©e locale) ou s'il est accessible depuis d'autres h√¥tes (port√©e globale).
La port√©e d√©termine la mani√®re dont les conteneurs peuvent communiquer avec ce r√©seau, en fonction de la configuration de Docker.
--

== üîçüåê Les r√©seaux : inspection

[source,bash]
----
docker network inspect bridge
----

[%step]
[source,bash]
----
[
    {
        "Name": "bridge",
        "Id": "11b7af7b16e4cf9fe42733aa1b6900ed876407e3b55e692c9dfe03505e2af19f",
        "Created": "2023-10-31T15:08:44.054140179Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        ...
----

[.notes]
--
Lorsque vous ex√©cutez la commande "docker network inspect bridge," vous obtenez des informations sur le r√©seau "bridge" dans Docker.

Voici ce que chaque √©l√©ment signifie :

1. **Name (Nom)** : C'est le nom du r√©seau, dans ce cas, "bridge." Docker attribue un nom par d√©faut √† ce r√©seau, qui est utilis√© par les conteneurs pour communiquer entre eux.
2. **Id (Identifiant)** : C'est un identifiant unique attribu√© au r√©seau Docker, utilis√© en interne par Docker pour le g√©rer. Il est g√©n√©r√© automatiquement.
3. **Created (Cr√©√©)** : Cette date indique quand le r√©seau a √©t√© cr√©√©. Cela peut √™tre utile pour suivre l'historique des op√©rations Docker.
4. **Scope (Port√©e)** : Dans cet exemple, la port√©e est "local," ce qui signifie que le r√©seau "bridge" est uniquement accessible localement sur l'h√¥te Docker. Les conteneurs sur cet h√¥te peuvent se connecter au r√©seau "bridge," mais les conteneurs sur d'autres h√¥tes Docker ne le peuvent pas.
5. **Driver (Pilote)** : Le pilote du r√©seau "bridge" est "bridge." C'est le pilote par d√©faut utilis√© pour connecter les conteneurs sur un m√™me h√¥te.
6. **EnableIPv6 (Activer IPv6)** : Dans cet exemple, la valeur est "false," ce qui signifie que l'IPv6 n'est pas activ√© sur ce r√©seau. Docker prend en charge √† la fois l'IPv4 et l'IPv6.
7. **IPAM (IP Address Management - Gestion des adresses IP)** : C'est la section qui g√®re les adresses IP pour le r√©seau. Dans cet exemple, le pilote est "default," ce qui signifie que Docker utilise ses param√®tres par d√©faut pour g√©rer les adresses IP.
8. **Subnet (Sous-r√©seau)** : C'est l'intervalle d'adresses IP utilis√© par les conteneurs connect√©s √† ce r√©seau. Dans cet exemple, le sous-r√©seau est "172.17.0.0/16," ce qui signifie que les adresses IP de ce r√©seau sont comprises entre 172.17.0.1 et 172.17.255.254.
9. **Gateway (Passerelle)** : Il s'agit de l'adresse IP de la passerelle utilis√©e par les conteneurs pour acc√©der √† d'autres r√©seaux ou √† Internet. Dans ce cas, la passerelle est "172.17.0.1."

Ces informations fournissent un aper√ßu de la configuration du r√©seau "bridge" dans Docker.
--

== üåê‚ú® Les r√©seaux : cr√©ation

[source,bash]
----
docker network create mon-reseau
----

[%step]
[source,bash]
----
docker network ls
----

[%step]
[source,bash]
----
NETWORK ID     NAME                                                             DRIVER    SCOPE
11b7af7b16e4   bridge                                                           bridge    local
1112832d205b   cours-devops-docker_default                                      bridge    local
7ab15cc28199   docker_volumes-backup-extension-desktop-extension_default        bridge    local
34caf4674478   host                                                             host      local
46953dc9b3d5   mon-reseau                                                       bridge    local
2a179c7be3b3   none                                                             null      local
0c577a792771   portainer_portainer-docker-extension-desktop-extension_default   bridge    local
----

[.notes]
--
Lorsque vous ex√©cutez la commande "docker network create mon-reseau," vous cr√©ez un nouveau r√©seau Docker avec le nom "mon-reseau." Voici ce que chaque √©l√©ment signifie :

1. **NETWORK ID (Identifiant du r√©seau)** : C'est un identifiant unique attribu√© au r√©seau que Docker utilise en interne pour le g√©rer. Il est g√©n√©r√© automatiquement.
2. **NAME (Nom)** : Il s'agit du nom que vous avez choisi pour votre r√©seau, dans ce cas, "mon-reseau."
3. **DRIVER (Pilote)** : Le pilote de ce r√©seau est "bridge." Le pilote "bridge" est utilis√© pour connecter des conteneurs sur le m√™me h√¥te.
4. **SCOPE (Port√©e)** : Dans cet exemple, la port√©e est "local," ce qui signifie que le r√©seau "mon-reseau" est uniquement accessible localement sur l'h√¥te Docker. Les conteneurs sur cet h√¥te peuvent se connecter √† "mon-reseau," mais les conteneurs sur d'autres h√¥tes Docker ne le peuvent pas.

Ensuite, lorsque vous ex√©cutez "docker network ls," vous obtenez une liste de tous les r√©seaux Docker existants, y compris celui que vous venez de cr√©er ("mon-reseau").
Vous pouvez voir les d√©tails de ce r√©seau dans le tableau, y compris son identifiant, son nom, son pilote, et sa port√©e.

En r√©sum√©, avec ces commandes, vous avez cr√©√© un nouveau r√©seau Docker nomm√© "mon-reseau" qui peut √™tre utilis√© pour connecter des conteneurs sur le m√™me h√¥te.
--

== üê≥üîó Attacher un container √† un r√©seau particulier

[source,bash]
----
docker run ‚Äìd --net=mon-reseau --name=app img
----

[%step]
Il est opportun de nommer un container quand on l'attache √† un r√©seau.

[%step]
Docker fournit un DNS interne dans les r√©seaux custom. Les containers d'un m√™me r√©seau peuvent se "voir" et "s'appeler" par leur noms.

[%auto-animate]
== üñ•Ô∏èüîç MicroDNS

[source,bash]
----
docker network create mynet
----

[%step]
[source,bash]
----
docker container run -d --name web --net mynet nginx
----

[%step]
[source,bash]
----
docker container run --net mynet alpine ping web
----

[%step]
[source,bash]
----
PING web (172.21.0.2): 56 data bytes
64 bytes from 172.21.0.2: seq=0 ttl=64 time=0.442 ms
64 bytes from 172.21.0.2: seq=1 ttl=64 time=0.105 ms
64 bytes from 172.21.0.2: seq=2 ttl=64 time=0.099 ms
64 bytes from 172.21.0.2: seq=3 ttl=64 time=0.150 ms
64 bytes from 172.21.0.2: seq=4 ttl=64 time=0.114 ms
64 bytes from 172.21.0.2: seq=5 ttl=64 time=0.098 ms
64 bytes from 172.21.0.2: seq=6 ttl=64 time=0.099 ms
64 bytes from 172.21.0.2: seq=7 ttl=64 time=0.100 ms
64 bytes from 172.21.0.2: seq=8 ttl=64 time=0.114 ms
64 bytes from 172.21.0.2: seq=9 ttl=64 time=0.097 ms
^C
--- web ping statistics ---
10 packets transmitted, 10 packets received, 0% packet loss
round-trip min/avg/max = 0.097/0.141/0.442 ms
----

[%auto-animate]
== üñ•Ô∏èüîç MicroDNS

image::appeler_son_voisin.png[height=600]

== üö® Pi√®ge NGINX : R√©solution DNS dans upstream blocks

[.notes]
--
Section duration: 7 minutes
Problem: NGINX resolves DNS at startup only, not dynamically like other tools
Impact: Common exam failure (+1.20 points average)
--

=== Le Probl√®me

NGINX, contrairement √† d'autres outils (curl, wget, applications), **r√©sout les noms DNS au d√©marrage uniquement**.

[%step]
* Si un service Docker n'est pas encore d√©marr√© ‚Üí NGINX **√©choue au d√©marrage**
* Si un conteneur red√©marre et change d'IP ‚Üí NGINX continue d'utiliser l'**ancienne IP**
* Erreur typique : `host not found in upstream "nom-service:port"`

=== Exemple de Configuration D√©faillante

[source,nginx]
----
events {
    worker_connections 1024;
}

http {
    # ‚ùå AUCUNE directive resolver !

    upstream backend {
        server app-server:8080;  # ‚ùå √âCHEC au d√©marrage !
    }

    server {
        listen 80;
        location / {
            proxy_pass http://backend;
        }
    }
}
----

**R√©sultat** : `nginx: [emerg] host not found in upstream "app-server"`

=== La Solution : Directive `resolver` + Variables

[source,nginx]
----
events {
    worker_connections 1024;
}

http {
    # DNS interne Docker pour r√©solution dynamique
    resolver 127.0.0.11 valid=30s ipv6=off;

    server {
        listen 80;
        location / {
            # ‚úÖ Utiliser une variable pour forcer la r√©solution dynamique
            set $backend_host "app-server:8080";
            proxy_pass http://$backend_host;
        }
    }
}
----

[IMPORTANT]
====
La directive `resolver` **seule ne suffit pas** avec les blocs `upstream` et noms fixes !

**Deux approches fonctionnelles** :

1. **Approche variable (recommand√©e pour Docker)** :
   - Pas de bloc `upstream`
   - Utiliser `set $var "nom-service:port"`
   - Puis `proxy_pass http://$var`
   - ‚úÖ Force la r√©solution DNS √† chaque requ√™te

2. **Approche upstream** :
   - Garder le bloc `upstream` pour load balancing
   - N√©cessite configurations avanc√©es (variables + health checks)
   - Plus complexe √† maintenir

Pour la plupart des cas Docker simples ‚Üí **Approche variable**
====

[TIP]
====
**127.0.0.11** est l'adresse du **DNS interne Docker** dans les **r√©seaux d√©finis par l'utilisateur** (user-defined networks).

[NOTE]
Le r√©seau `bridge` par d√©faut n'a pas de serveur DNS - utilisez `docker network create` pour cr√©er un r√©seau personnalis√©.
====

=== Quand est-ce n√©cessaire ?

[cols="2,3,1", options="header"]
|===
| Situation
| Directive `resolver` n√©cessaire ?
| Raison

| upstream block avec noms Docker (statique)
| ‚ö†Ô∏è INSUFFISANT
| N√©cessite AUSSI variables + proxy_pass

| proxy_pass avec variable (`$backend_host`)
| ‚úÖ OUI + obligatoire
| Force r√©solution dynamique √† chaque requ√™te

| upstream avec IP fixe
| ‚ùå NON
| Pas de r√©solution DNS

| proxy_pass avec nom fixe (sans upstream)
| ‚ö†Ô∏è RECOMMAND√â
| √âvite erreurs au red√©marrage

| proxy_pass avec variable
| ‚úÖ OUI
| R√©solution dynamique obligatoire
|===

=== Param√®tres de la Directive `resolver`

[source,nginx]
----
resolver 127.0.0.11 valid=30s ipv6=off;
#        ^^^^^^^^^^^ ^^^^^^^^^ ^^^^^^^^
#        Adresse DNS  Cache TTL D√©sactiver IPv6
----

[%step]
* **127.0.0.11** : DNS interne Docker (toujours cette adresse dans Docker)
* **valid=30s** : Dur√©e de cache des r√©solutions (30 secondes par d√©faut)
* **ipv6=off** : D√©sactive IPv6 (optionnel, √©vite warnings)

=== üéì Exercice Pratique

Cr√©ez un projet avec :

1. **NGINX** (proxy) utilisant upstream vers `webapp`
2. **webapp** (serveur web simple sur port 8080)

[source,yaml]
----
services:
  webapp:
    image: nginx:alpine
    ports:
      - "8080:80"

  proxy:
    image: nginx:latest
    ports:
      - "8000:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
----

**Test 1** : Sans `resolver` ‚Üí Observer l'√©chec NGINX

**Test 2** : Avec `resolver 127.0.0.11` ‚Üí Succ√®s !

=== üìä En R√©sum√©

[TIP]
====
**R√®gle d'or** : upstream block avec noms Docker ‚Üí **DOIT avoir resolver**

[source,nginx]
----
http {
    resolver 127.0.0.11 valid=30s ipv6=off;
    # ...
}
----
====

[WARNING]
====
Sans cette directive, vous aurez :

* ‚ùå √âchecs au d√©marrage si services pas encore pr√™ts
* ‚ùå IPs obsol√®tes apr√®s red√©marrage de conteneurs
* ‚ùå Erreur : `host not found in upstream`
====

== üì∂üîå Se connecter √† un r√©seau

[source,bash]
----
docker network connect mynet myapp
----

[%step]
Cette commande permet d'attacher un container √† un r√©seau apr√®s sa cr√©ation.


== üéì Travaux pratiques #11

√âtapes:

[%step]
* Lister et inspecter les r√©seaux existants
* Lancer un container `nginx `nomm√© "web1"
* A quel r√©seau est-il attach√© ?
* Cr√©er un r√©seau de type bridge et l'inspecter
* Lancer un container `nginx` nomm√© "web2" et l'attacher au r√©seau cr√©√©
* L'inspection confirme-t-elle l'attachement ?
* Lancer un bash dans le container "web1"
* Est-ce que "web1" peut voir "web2" ?
* Corriger pour que ce soit le cas

[%auto-animate]
== ‚úÖ Solution travaux pratiques #11

√âtape 1 : Lister et inspecter les r√©seaux existants

[source,bash]
----
# Liste tous les r√©seaux Docker existants
docker network ls

# Inspecte un r√©seau sp√©cifique (par exemple, le r√©seau bridge, d'autres r√©seaux peuvent √™tre inspect√©s)
docker network inspect bridge
----

[%step]
√âtape 2 : Lancer un container "nginx" nomm√© "web1"
[%step]
[source,bash]
----
# Lance un conteneur "nginx" nomm√© "web1"
docker container run --name web1 -d nginx
----

[%step]
√âtape 3 : V√©rifier le r√©seau auquel "web1" est attach√©
[%step]
[source,bash]
----
# R√©cup√®re l'identifiant de r√©seau complet pour le container "web1"
network_id=$(docker container inspect -f '{{.NetworkSettings.Networks.bridge.NetworkID}}' web1)

# Raccourcit l'identifiant du r√©seau aux premiers 12 caract√®res
shortened_network_id=$(echo $network_id | cut -c 1-12)

# Liste tous les r√©seaux docker, en filtrant par l'identifiant du r√©seau
docker network ls --format "table {{.ID}}\t{{.Name}}" | awk -v network_id="$shortened_network_id" '$1 == network_id {print $2}'
----

[%auto-animate]
== ‚úÖ Solution travaux pratiques #11

√âtape 3 : V√©rifier le r√©seau auquel "web1" est attach√©
[source,bash]
----
# R√©cup√®re l'identifiant de r√©seau complet pour le container "web1"
network_id=$(docker container inspect -f '{{.NetworkSettings.Networks.bridge.NetworkID}}' web1)

# Raccourcit l'identifiant du r√©seau aux premiers 12 caract√®res
shortened_network_id=$(echo $network_id | cut -c 1-12)

# Liste tous les r√©seaux docker, en filtrant par l'identifiant du r√©seau
docker network ls --format "table {{.ID}}\t{{.Name}}" | awk -v network_id="$shortened_network_id" '$1 == network_id {print $2}'
----
[source,bash]
----
bridge
----

[%step]
√âtape 4 : Cr√©er un r√©seau de type bridge et l'inspecter
[%step]
[source,bash]
----
# Cr√©e un r√©seau Docker de type bridge nomm√© "mon-reseau"
docker network create mon-reseau

# Inspecte le r√©seau "mon-reseau"
docker network inspect mon-reseau
----

[%step]
√âtape 5 : Lancer un container "nginx" nomm√© "web2" et l'attacher au r√©seau cr√©√©
[%step]
[source,bash]
----
# Lance un conteneur "nginx" nomm√© "web2" et l'attache au r√©seau "mon-reseau"
docker container run --name web2 -d --network mon-reseau nginx
----

[%auto-animate]
== ‚úÖ Solution travaux pratiques #11

√âtape 5 : Lancer un container "nginx" nomm√© "web2" et l'attacher au r√©seau cr√©√©
[source,bash]
----
# Lance un conteneur "nginx" nomm√© "web2" et l'attache au r√©seau "mon-reseau"
docker container run --name web2 -d --network mon-reseau nginx
----

√âtape 6 : V√©rifier l'attachement du container "web2" au r√©seau
[%step]
[source,bash]
----
# Inspecte le conteneur "web2" pour v√©rifier le r√©seau auquel il est attach√©
docker container inspect web2 | grep NetworkMode
----

[%step]
√âtape 7 : Lancer un bash dans le container "web1"
[%step]
[source,bash]
----
# Lance un shell interactif dans le conteneur "web1"
docker container exec -it web1 bash
----

[%step]
√âtape 8 : V√©rifier si "web1" peut voir "web2"
[%step]
[source,bash]
----
# √Ä l'int√©rieur du conteneur "web1," essayez de faire une requ√™te HTTP vers "web2"
curl web2
----
[%step]
[source,bash]
----
curl: (6) Could not resolve host: web2
----

[%auto-animate]
== ‚úÖ Solution travaux pratiques #11

√âtape 9 : Corriger pour permettre la communication entre "web1" et "web2"
[%step]
[source,bash]
----
# Sortez du shell du conteneur "web1" en tapant "exit"

# Attachez "web1" au m√™me r√©seau "mon-reseau"
docker network connect mon-reseau web1
----
[%step]
Apr√®s avoir suivi ces √©tapes, les conteneurs "web1" et "web2" devraient √™tre attach√©s au m√™me r√©seau "mon-reseau" et √™tre capables de communiquer entre eux.

[%step]
[source,bash]
----
# Lance un shell interactif dans le conteneur "web1"
docker container exec -it web1 bash
----

[%step]
[source,bash]
----
# √Ä l'int√©rieur du conteneur "web1," essayez de faire une requ√™te HTTP vers "web2"
curl web2
----

[%step]
[source,html]
----
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
[...]
----

== üö® Pi√®ge : localhost vs nom de service dans Docker

[.notes]
--
Section duration: 8 minutes
Real student error: GELF logging to localhost instead of service name
Impact: Common exam failure (+1.30 points average)
--

=== La Confusion Fatale

[cols="2,3,3", options="header"]
|===
| Terme
| Hors Docker (machine locale)
| Dans Docker (environnement conteneuris√©)

| `localhost`
| Votre ordinateur
| **Le conteneur actuel uniquement**

| `127.0.0.1`
| Votre ordinateur
| **Le conteneur actuel uniquement**

| `nom_service`
| _(n'existe pas)_
| **Un autre conteneur du m√™me r√©seau**

| `nom_service:port`
| _(n'existe pas)_
| **Communication inter-conteneurs**
|===

[WARNING]
====
**Dans Docker** : `localhost` ‚â† autre conteneur

`localhost` = seulement le conteneur o√π vous √™tes !
====

=== Exemples d'Erreurs R√©elles

Ces erreurs proviennent d'examens r√©els (2025-2026).

==== Erreur #1 : Logging GELF vers localhost

**Code cass√©** :

[source,yaml]
----
services:
  backend:
    image: mon-app
    logging:
      driver: gelf
      options:
        gelf-address: "udp://localhost:12201"  # ‚ùå FAUX !
        tag: "backend"

  logstash:
    image: logstash:latest
    ports:
      - "12201:12201/udp"
----

**Probl√®me** : `localhost:12201` pointe vers le **conteneur backend**, pas vers logstash !

**Solution** :

[source,yaml]
----
services:
  backend:
    logging:
      driver: gelf
      options:
        gelf-address: "udp://logstash:12201"  # ‚úÖ Nom du service !
----

==== Erreur #2 : Health Check avec localhost IPv6

**Code cass√©** :

[source,yaml]
----
services:
  webapp:
    image: node:18
    healthcheck:
      test: ["CMD", "curl", "-f", "http://[::1]:3000/health"]  # ‚ùå FAUX !
----

**Probl√®me** : `[::1]` (localhost IPv6) pointe vers le conteneur webapp lui-m√™me, mais si l'app √©coute sur IPv4...

**Solution** :

[source,yaml]
----
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:3000/health"]  # ‚úÖ OK (m√™me conteneur)
  # OU
  test: ["CMD", "curl", "-f", "http://127.0.0.1:3000/health"]  # ‚úÖ OK
----

[NOTE]
====
Health check = test **dans le m√™me conteneur** ‚Üí `localhost` est **correct** ici !

C'est quand on veut **acc√©der √† un autre service** qu'il faut utiliser le nom du service.
====

==== Erreur #3 : Backend URL avec localhost

**Code cass√© (frontend)** :

[source,javascript]
----
// frontend/src/config.js
const API_URL = "http://localhost:5000/api";  // ‚ùå FAUX !
----

**Probl√®me** : Le navigateur du client ex√©cute ce code ‚Üí `localhost` pointe vers **l'ordinateur du client**, pas le backend Docker !

**Solution 1** : Utiliser un reverse proxy (NGINX)

[source,javascript]
----
const API_URL = "/api";  # ‚úÖ Relatif ‚Üí passe par NGINX
----

**Solution 2** : Variable d'environnement

[source,javascript]
----
const API_URL = process.env.REACT_APP_API_URL || "http://backend:5000/api";
----

[source,yaml]
----
services:
  frontend:
    environment:
      REACT_APP_API_URL: "http://backend:5000/api"  # ‚úÖ Nom de service
----

=== Tableau de R√©f√©rence Rapide

[cols="3,2,2", options="header"]
|===
| Situation
| Utiliser
| Exemple

| Health check (m√™me conteneur)
| `localhost` ou `127.0.0.1`
| `curl http://localhost:8080/health`

| Communication entre services Docker
| **Nom du service**
| `http://backend:5000`

| Logging GELF vers Logstash
| **Nom du service**
| `gelf-address: "udp://logstash:12201"`

| Adresse de connexion base de donn√©es
| **Nom du service**
| `DATABASE_URL=postgresql://db:5432/mydb`

| API frontend ‚Üí backend (m√™me r√©seau Docker)
| **Nom du service**
| `API_URL=http://backend:5000`

| API frontend ‚Üí backend (navigateur client)
| **Reverse proxy**
| `API_URL=/api` (NGINX route vers backend)
|===

=== R√®gle Mn√©motechnique

[TIP]
====
**Localhost = Local Container**

* `localhost` dans un conteneur = **ce conteneur uniquement**
* Pour parler √† un **autre conteneur** = utiliser son **nom de service**
* Pour parler depuis le **navigateur** = utiliser **reverse proxy** ou **URL publique**
====

=== üéì Exercice Pratique

Corrigez ce `docker-compose.yml` cass√© :

[source,yaml]
----
services:
  webapp:
    image: node:18
    environment:
      DATABASE_URL: "postgresql://localhost:5432/mydb"  # ‚ùå Erreur 1
      REDIS_URL: "redis://127.0.0.1:6379"              # ‚ùå Erreur 2
    logging:
      driver: gelf
      options:
        gelf-address: "udp://localhost:12201"          # ‚ùå Erreur 3

  database:
    image: postgres:15

  cache:
    image: redis:7

  logstash:
    image: logstash:latest
    ports:
      - "12201:12201/udp"
----

**Solution** : Remplacer tous les `localhost` par les noms de services !

=== üìä En R√©sum√©

[WARNING]
====
**Erreurs fr√©quentes** :

* ‚ùå `localhost:5432` pour PostgreSQL ‚Üí **Utiliser** `database:5432`
* ‚ùå `localhost:6379` pour Redis ‚Üí **Utiliser** `cache:6379`
* ‚ùå `localhost:12201` pour GELF logging ‚Üí **Utiliser** `logstash:12201`
* ‚ùå `localhost` dans variables d'environnement ‚Üí **Utiliser nom de service**
====

[TIP]
====
**R√®gle d'or** :

* M√™me conteneur ‚Üí `localhost` ‚úÖ
* Autre conteneur ‚Üí **nom du service** ‚úÖ
* Depuis navigateur ‚Üí **reverse proxy** ‚úÖ
====
