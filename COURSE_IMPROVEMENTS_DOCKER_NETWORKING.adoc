= Am√©liorations du Cours : Pi√®ges Courants Docker & Reverse Proxy
:toc: left
:toclevels: 3
:sectnums:
:icons: font
:source-highlighter: rouge
:experimental:
:stem:

== Contexte

=== Origine de ce Document

Suite √† l'analyse des projets d'√©tudiants de l'examen final 2025-2026 (bin√¥mes avec reverse proxy + serveur d'application Java), **trois erreurs critiques** sont apparues de mani√®re r√©currente dans les projets les moins bien not√©s :

1. **R√©solution DNS NGINX manquante** : `resolver 127.0.0.11` absent dans nginx.conf
2. **Outils manquants dans les images de base** : `curl` absent pour les health checks
3. **Confusion localhost vs nom de service** : Utilisation de `localhost` au lieu du nom de service Docker

Ces trois erreurs simples ont caus√© :

* **√âchec complet des tests fonctionnels** (0.0/2.0 points)
* **Conteneurs qui ne d√©marrent jamais** (status: "Created" ou crash loops)
* **Notes finales catastrophiques** : F (Insuffisant) alors que l'architecture √©tait correcte

[IMPORTANT]
====
**Pattern commun identifi√©** : Les √©tudiants d√©montrent une **forte compr√©hension architecturale** (docker-compose bien structur√©, volumes, r√©seaux personnalis√©s, ELK stack) mais √©chouent sur des **d√©tails techniques Docker/NGINX** qui ne sont pas explicitement couverts dans le cours.
====

=== Impact des Corrections

[cols="1,2,1,2,1", options="header"]
|===
| √âtudiant | Probl√®me | Fix | Impact | Nouveau Grade

| √âtudiant A
| NGINX DNS resolution failure
| 1 ligne (`resolver 127.0.0.11`)
| +1.20 pts
| F ‚Üí C

| √âtudiant B
| Curl manquant pour health checks
| 1 commande RUN
| ~+1.5 pts
| F ‚Üí C/D

| √âtudiant C
| GELF logging avec localhost
| 2 mots chang√©s
| +1.30 pts
| F ‚Üí D
|===

**Conclusion** : Des changements minuscules (1 ligne de code) transforment des √©checs en r√©ussites. Le cours doit couvrir ces pi√®ges.

== Gaps Identifi√©s dans le Cours Actuel

=== Gap #1 : R√©solution DNS NGINX (`resolver 127.0.0.11`)

==== Ce qui existe actuellement

* **Chapitre 11 (reseaux.adoc)** :
** Couvre Docker DNS et MicroDNS (lignes 313-350)
** Montre que les conteneurs peuvent s'appeler par nom
** Exemple : `docker container run --net mynet alpine ping web`

* **SecureVote Phase 1 (proxy/nginx.conf)** :
** Utilise des `upstream` blocks avec noms de service
** **MAIS** : Pas de directive `resolver` !

[source,nginx]
----
upstream frontend {
    server frontend:3000;  # ‚Üê Fonctionne SEULEMENT si frontend d√©marre avant nginx
}

upstream backend {
    server backend:5000;   # ‚Üê Fonctionne SEULEMENT si backend d√©marre avant nginx
}
----

==== Ce qui manque

[WARNING]
====
**Probl√®me critique** : NGINX r√©sout les hostnames des `upstream` blocks **au d√©marrage uniquement**, pas dynamiquement comme d'autres outils.

Sans `resolver 127.0.0.11`, NGINX :

1. Essaie de r√©soudre `frontend:3000` via `/etc/resolv.conf` (DNS syst√®me)
2. Le DNS syst√®me ne conna√Æt PAS les noms de service Docker
3. NGINX affiche : `nginx: [emerg] host not found in upstream "frontend:3000"`
4. Le conteneur ne d√©marre JAMAIS (status: "Created")
====

==== Ce qu'il faut ajouter au cours

**Localisation sugg√©r√©e** : Nouveau sous-chapitre dans `reseaux.adoc` apr√®s la section MicroDNS.

**Titre sugg√©r√©** : "üö® Pi√®ge NGINX : R√©solution DNS dans upstream blocks"

**Contenu propos√©** :

[source,asciidoc]
----
== üö® Pi√®ge NGINX : R√©solution DNS dans upstream blocks

=== Le Probl√®me

NGINX a un comportement **diff√©rent** des autres outils Docker concernant la r√©solution DNS :

[%step]
* La plupart des outils r√©solvent les noms de service **dynamiquement** (√† chaque requ√™te)
* NGINX r√©sout les hostnames dans `upstream` blocks **une seule fois au d√©marrage**
* Sans configuration sp√©ciale, NGINX utilise `/etc/resolv.conf` (DNS syst√®me)
* Le DNS syst√®me Docker **ne conna√Æt pas** les noms de service Docker

=== Exemple de Configuration D√©faillante

[source,nginx]
----
events {}

http {
    upstream backend {
        server app-server:8080;  # ‚ùå √âCHEC au d√©marrage !
    }

    server {
        listen 80;
        location / {
            proxy_pass http://backend;
        }
    }
}
----

**Erreur au d√©marrage** :
[source,bash]
----
nginx: [emerg] host not found in upstream "app-server:8080" in /etc/nginx/nginx.conf:5
----

**Le conteneur ne d√©marre jamais !**

=== La Solution : Directive `resolver`

Docker fournit un **serveur DNS interne** √† l'adresse **127.0.0.11** qui conna√Æt tous les noms de service.

[source,nginx]
----
events {}

http {
    # ‚úÖ Indique √† NGINX d'utiliser le DNS interne Docker
    resolver 127.0.0.11 valid=30s ipv6=off;

    upstream backend {
        server app-server:8080;  # ‚úÖ Fonctionne maintenant !
    }

    server {
        listen 80;
        location / {
            proxy_pass http://backend;
        }
    }
}
----

**Explication des param√®tres** :

* `127.0.0.11` : Adresse du DNS interne Docker (fixe pour tous les r√©seaux)
* `valid=30s` : Cache DNS pendant 30 secondes (√©vite trop de requ√™tes DNS)
* `ipv6=off` : D√©sactive IPv6 (plus rapide, √©vite les probl√®mes IPv6 Docker)

=== Quand est-ce n√©cessaire ?

[cols="2,3,1", options="header"]
|===
| Situation | Directive `resolver` n√©cessaire ? | Raison

| `upstream` avec noms de service Docker
| ‚úÖ **OUI**
| NGINX doit r√©soudre via DNS Docker

| `upstream` avec adresses IP
| ‚ùå Non
| Pas de r√©solution DNS n√©cessaire

| `proxy_pass` direct sans upstream
| ‚ö†Ô∏è Parfois
| Requis SEULEMENT si utilisation de variables (ex: `$backend_host`). Pas n√©cessaire pour noms fixes.

| Services d√©marrent dans le bon ordre
| ‚úÖ **OUI quand m√™me**
| Plus robuste, fonctionne toujours
|===

[WARNING]
====
**M√™me si vos services d√©marrent dans le bon ordre**, ajoutez TOUJOURS `resolver 127.0.0.11` dans vos configurations NGINX avec upstream blocks. C'est une **bonne pratique** qui garantit la robustesse.
====

=== üéì Exercice Pratique

Cr√©ez un projet avec :

1. Un service `nginx` avec upstream vers `webapp`
2. Un service `webapp` (nginx ou autre)

**Sans `resolver`** :
* D√©marrez : les services crashent
* Regardez les logs : `host not found`

**Avec `resolver 127.0.0.11`** :
* D√©marrez : tout fonctionne
* Testez : `curl http://localhost/`

=== üìä En R√©sum√©

[TIP]
====
**R√®gle d'or NGINX + Docker** :

Si votre nginx.conf contient :
[source,nginx]
----
upstream nom_service {
    server autre_service:port;
}
----

Alors votre nginx.conf DOIT contenir :
[source,nginx]
----
http {
    resolver 127.0.0.11 valid=30s ipv6=off;
    # ...
}
----
====
----

=== Gap #2 : Outils Manquants dans Images de Base

==== Ce qui existe actuellement

* **Chapitre 12 (compose.adoc)** :
** Couvre extensivement les health checks (lignes 269-542)
** Montre des exemples avec `pg_isready`, test de fichier, etc.
** Exemple Jenkins avec healthcheck sophistiqu√©

[source,yaml]
----
healthcheck:
  test: ["CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1"]
  interval: 5s
  timeout: 10s
  retries: 5
----

==== Ce qui manque

[WARNING]
====
**Probl√®me critique** : Les exemples supposent que les commandes utilis√©es (`wget`, `curl`, `[ ]`) existent dans l'image de base.

**R√©alit√©** : Les images **slim** ou **Alpine** n'incluent PAS ces outils par d√©faut !

Exemple typique d'√©chec :
[source,bash]
----
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
----

**Erreur** : `/bin/sh: curl: not found` ‚Üí Health check toujours "unhealthy" !
====

==== Ce qu'il faut ajouter au cours

**Localisation sugg√©r√©e** : Section suppl√©mentaire dans le chapitre health checks de `compose.adoc`

**Titre sugg√©r√©** : "‚ö†Ô∏è Pi√®ge : Outils manquants dans les images de base"

**Contenu propos√©** :

[source,asciidoc]
----
== ‚ö†Ô∏è Pi√®ge : Outils manquants dans les images de base

=== Le Probl√®me

Les health checks utilisent des **commandes shell** ex√©cut√©es **√† l'int√©rieur du conteneur**.

[IMPORTANT]
====
**Si la commande n'existe pas dans l'image, le health check √©choue syst√©matiquement !**
====

=== Exemples d'Images et Outils Disponibles

[cols="2,2,3", options="header"]
|===
| Image de Base | Outils Inclus | Outils ABSENTS

| `debian:12` (full)
| bash, curl, wget, ps, netcat
| (rare)

| `debian:12-slim`
| sh, ps
| ‚ùå curl, wget, netcat, bash

| `alpine:3.19`
| sh, wget, ps
| ‚ùå curl, bash, netcat

| `ubuntu:22.04`
| bash, curl, wget
| (rare)

| `nginx:alpine`
| sh, wget
| ‚ùå curl, bash

| `python:3.11-slim`
| python, ps
| ‚ùå curl, wget, bash
|===

=== Sympt√¥mes d'un Health Check avec Outil Manquant

**docker ps** affiche :
[source,bash]
----
CONTAINER ID   STATUS
abc123         Up 2 minutes (unhealthy)  # ‚Üê Health check √©choue !
----

**docker inspect** montre :
[source,json]
----
"Health": {
    "Status": "unhealthy",
    "FailingStreak": 15,
    "Log": [
        {
            "ExitCode": 127,
            "Output": "/bin/sh: curl: not found\n"
        }
    ]
}
----

[TIP]
====
**ExitCode 127** = "Command not found" ‚Üí L'outil n'existe pas dans l'image !
====

=== Solution 1 : Installer l'Outil dans le Dockerfile

**Exemple : Ajouter curl dans une image Debian slim**

[source,dockerfile]
----
FROM debian:12-slim

# Installer curl pour les health checks
RUN apt-get update && \
    apt-get install -y --no-install-recommends curl && \
    rm -rf /var/lib/apt/lists/*

# Reste de votre Dockerfile...
COPY app.py /app/
CMD ["python", "/app/app.py"]
----

**Exemple : Ajouter curl dans une image Alpine**

[source,dockerfile]
----
FROM alpine:3.19

# Installer curl pour les health checks
RUN apk add --no-cache curl

# Reste de votre Dockerfile...
COPY app.py /app/
CMD ["python", "/app/app.py"]
----

=== Solution 2 : Utiliser des Alternatives Natives

Si vous ne voulez PAS ajouter de d√©pendances, utilisez des outils **d√©j√† pr√©sents** :

**Alternative √† `curl` : Test de fichier**

Au lieu de :
[source,yaml]
----
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8080/health"]  # ‚ùå curl absent
----

Utilisez :
[source,yaml]
----
healthcheck:
  test: ["CMD-SHELL", "[ -f /app/ready ] || exit 1"]  # ‚úÖ [ ] toujours pr√©sent
----

**Alternative √† `curl` : wget (pr√©sent dans Alpine)**

[source,yaml]
----
healthcheck:
  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health"]
----

**Alternative √† `curl` : netcat/nc**

[source,yaml]
----
healthcheck:
  test: ["CMD-SHELL", "nc -z localhost 8080 || exit 1"]  # Teste juste la connexion TCP
----

=== Solution 3 : Utiliser Python/Node Built-in

Si votre image contient **Python** ou **Node.js**, utilisez-les :

**Health check avec Python** :
[source,yaml]
----
healthcheck:
  test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8080/health')"]
----

**Health check avec Node.js** :
[source,yaml]
----
healthcheck:
  test: ["CMD", "node", "-e", "require('http').get('http://localhost:8080/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1)).on('error', () => process.exit(1))"]
----

=== üéì Exercice Pratique

1. Cr√©ez un Dockerfile bas√© sur `debian:12-slim`
2. Ajoutez un health check avec `curl`
3. Lancez : observez "unhealthy"
4. Modifiez le Dockerfile pour installer `curl`
5. Relancez : observez "healthy"

=== üìä En R√©sum√©

[TIP]
====
**Checklist Health Check** :

‚òëÔ∏è V√©rifiez que la commande existe dans l'image de base

‚òëÔ∏è Si absent : installez-le dans le Dockerfile

‚òëÔ∏è Ou utilisez une alternative native (wget, test fichier, etc.)

‚òëÔ∏è Testez avec `docker exec -it container nom_commande`
====
----

=== Gap #3 : Localhost vs Nom de Service Docker

==== Ce qui existe actuellement

* **Chapitre 11 (reseaux.adoc)** :
** Montre les conteneurs s'appelant par nom (lignes 299-351)
** Exemple ping : `docker container run --net mynet alpine ping web`
** Explique le DNS interne Docker

==== Ce qui manque

[WARNING]
====
**Confusion critique** : Dans Docker, `localhost` ‚â† nom de service.

* `localhost` = le conteneur lui-m√™me (127.0.0.1)
* `nom_service` = un AUTRE conteneur dans le r√©seau Docker

**Erreur fr√©quente** : Configuration de logging, monitoring, proxy avec `localhost` au lieu du nom de service.

Exemple r√©el √©tudiant :
[source,yaml]
----
logging:
  driver: gelf
  options:
    gelf-address: "udp://localhost:12201"  # ‚ùå FAUX : localhost = conteneur actuel, pas logstash !
----

**R√©sultat** : Le conteneur essaie d'envoyer les logs au port 12201 de **lui-m√™me**, √©choue, et crash en boucle infinie.
====

==== Ce qu'il faut ajouter au cours

**Localisation sugg√©r√©e** : Nouvelle section dans `reseaux.adoc` apr√®s la section sur les r√©seaux personnalis√©s.

**Titre sugg√©r√©** : "üö® Pi√®ge : localhost vs nom de service dans Docker"

**Contenu propos√©** :

[source,asciidoc]
----
== üö® Pi√®ge : localhost vs nom de service dans Docker

=== La Confusion Fatale

Dans un environnement **sans conteneurs**, `localhost` d√©signe **la machine locale**.

Dans Docker, **chaque conteneur a son propre localhost** !

[cols="2,3,3", options="header"]
|===
| Terme | Signification Hors Docker | Signification Dans Docker

| `localhost`
| La machine locale
| **Le conteneur actuel** (pas les autres !)

| `127.0.0.1`
| Interface loopback locale
| Interface loopback **du conteneur**

| `nom_service`
| (n'existe pas)
| **Un autre conteneur** dans le r√©seau Docker
|===

=== Exemples d'Erreurs R√©elles

==== Erreur #1 : Logging GELF vers localhost

[source,yaml]
----
services:
  nginx:
    image: nginx
    logging:
      driver: gelf
      options:
        gelf-address: "udp://localhost:12201"  # ‚ùå FAUX !
        tag: "nginx"

  logstash:
    image: logstash
    ports:
      - "12201:12201/udp"
----

**Probl√®me** :

* NGINX essaie d'envoyer les logs √† `localhost:12201` = **lui-m√™me**
* Logstash √©coute sur **son propre** `localhost:12201` = inaccessible depuis NGINX
* R√©sultat : NGINX crash car il ne peut pas se connecter √† son port 12201

**Solution** :

[source,yaml]
----
services:
  nginx:
    logging:
      driver: gelf
      options:
        gelf-address: "udp://logstash:12201"  # ‚úÖ Nom du service !
----

==== Erreur #2 : Health Check avec localhost IPv6

[source,yaml]
----
services:
  webapp:
    image: tomcat:9
    healthcheck:
      test: ["CMD", "wget", "--spider", "http://localhost:8080/"]  # ‚ö†Ô∏è Probl√®me IPv6
----

**Probl√®me subtil** :

* `localhost` peut r√©soudre vers `::1` (IPv6) ou `127.0.0.1` (IPv4)
* Tomcat √©coute parfois SEULEMENT sur IPv4
* Health check essaie IPv6 ‚Üí √©choue

**Solution** :

[source,yaml]
----
healthcheck:
  test: ["CMD", "wget", "--spider", "http://127.0.0.1:8080/"]  # ‚úÖ Force IPv4
----

==== Erreur #3 : Backend URL avec localhost

[source,yaml]
----
services:
  frontend:
    environment:
      API_URL: "http://localhost:5000"  # ‚ùå FAUX dans frontend !

  backend:
    ports:
      - "5000:5000"
----

**Probl√®me** :

* Frontend essaie d'appeler `http://localhost:5000`
* `localhost` dans frontend = le conteneur frontend lui-m√™me
* Backend n'est PAS sur localhost du frontend !

**Solutions possibles** :

[source,yaml]
----
# Solution 1 : Appel depuis le navigateur (client-side)
frontend:
  environment:
    API_URL: "http://localhost:5000"  # ‚úÖ Navigateur ‚Üí h√¥te Docker ‚Üí backend

# Solution 2 : Appel depuis le frontend (server-side)
frontend:
  environment:
    API_URL: "http://backend:5000"  # ‚úÖ Frontend ‚Üí r√©seau Docker ‚Üí backend
----

=== Tableau de R√©f√©rence

[cols="3,2,3", options="header"]
|===
| Contexte | Utilisez | Exemple

| Service A appelle service B (m√™me r√©seau)
| **Nom du service B**
| `http://backend:5000`

| Health check d'un service sur lui-m√™me
| `localhost` ou `127.0.0.1`
| `http://127.0.0.1:8080`

| Logging vers un autre service
| **Nom du service**
| `gelf-address: "udp://logstash:12201"`

| Port expos√© accessible depuis l'h√¥te
| `localhost` (sur l'h√¥te)
| `curl http://localhost:8080`

| Configuration r√©seau interne
| **Nom du service**
| `REDIS_URL: redis://cache:6379`
|===

=== R√®gle Mn√©motechnique

[TIP]
====
**"localhost" dans Docker = "moi-m√™me"**

Si vous voulez parler √† **un autre conteneur**, utilisez **son nom de service**.

Si vous voulez parler √† **vous-m√™me** (votre propre conteneur), utilisez `localhost`.
====

=== üéì Exercice Pratique

Cr√©ez deux services :

[source,yaml]
----
services:
  web:
    image: nginx
    networks:
      - mynet

  api:
    image: httpbin/httpbin
    networks:
      - mynet

networks:
  mynet:
----

Depuis `web`, essayez :

1. `curl http://localhost/get` ‚Üí Qui r√©pond ?
2. `curl http://api/get` ‚Üí Qui r√©pond ?
3. Comprenez la diff√©rence !

=== üìä En R√©sum√©

[IMPORTANT]
====
**Deux environnements r√©seau distincts** :

1. **R√©seau h√¥te** (votre machine) : `localhost` = votre PC
2. **R√©seau Docker** (conteneurs) :
   * `localhost` = le conteneur actuel
   * `nom_service` = un autre conteneur
====
----

== Am√©liorations du Projet SecureVote

=== Probl√®me Actuel

Le projet **SecureVote Phase 1** est utilis√© comme r√©f√©rence p√©dagogique mais contient des configurations **qui fonctionnent par chance** sans √™tre robustes.

=== Changements √† Apporter

==== Fichier : `content/code-samples/securevote/phase1/proxy/nginx.conf`

**Ligne 5 : Ajouter la directive resolver**

[source,diff]
----
events {
    worker_connections 1024;
}

http {
+    # DNS interne Docker pour r√©solution dynamique des services
+    resolver 127.0.0.11 valid=30s ipv6=off;
+
    # VULN√âRABILIT√â : Pas de limite de taille de requ√™te
    # VULN√âRABILIT√â : Pas de rate limiting
    # VULN√âRABILIT√â : Pas de headers de s√©curit√©

    upstream frontend {
        server frontend:3000;
    }
----

**Commentaire √† ajouter** : Expliquer POURQUOI c'est n√©cessaire dans les commentaires.

==== Fichier : `content/code-samples/securevote/phase1/docker-compose.yml`

**Ajouter health checks avec outils appropri√©s**

Pour PostgreSQL :
[source,yaml]
----
database:
  image: postgres:15
  healthcheck:
    test: ["CMD-SHELL", "pg_isready -U admin"]  # ‚úÖ pg_isready inclus dans postgres
    interval: 10s
    timeout: 5s
    retries: 5
----

Pour Redis :
[source,yaml]
----
cache:
  image: redis:7
  healthcheck:
    test: ["CMD", "redis-cli", "ping"]  # ‚úÖ redis-cli inclus dans redis
    interval: 10s
    timeout: 5s
    retries: 5
----

Pour Backend (Flask - si image custom) :
[source,dockerfile]
----
# Dans backend/Dockerfile
FROM python:3.11-slim

# Installer curl pour health check
RUN apt-get update && \
    apt-get install -y --no-install-recommends curl && \
    rm -rf /var/lib/apt/lists/*

# ... reste du Dockerfile
----

[source,yaml]
----
# Dans docker-compose.yml
backend:
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:5000/health"]  # ‚úÖ curl install√©
    interval: 10s
    timeout: 5s
    retries: 5
----

== Modifications Sugg√©r√©es par Chapitre

=== Chapitre 11 : R√©seaux (reseaux.adoc)

**Ajouts prioritaires** :

1. Nouvelle section "üö® Pi√®ge NGINX : R√©solution DNS dans upstream blocks" (apr√®s ligne 351)
2. Nouvelle section "üö® Pi√®ge : localhost vs nom de service dans Docker" (apr√®s ligne 517)
3. Modifier les exercices pratiques (#11) pour inclure un cas NGINX avec resolver

**Temps estim√© de pr√©sentation** : +10-15 minutes

=== Chapitre 12 : Docker Compose (compose.adoc)

**Ajouts prioritaires** :

1. Nouvelle section "‚ö†Ô∏è Pi√®ge : Outils manquants dans les images de base" (apr√®s ligne 542)
2. Ajouter un exemple Jenkins/GitLab avec installation de `curl` dans Dockerfile
3. Modifier le TP #12 pour inclure un health check qui √©choue puis r√©ussit apr√®s fix

**Temps estim√© de pr√©sentation** : +10 minutes

=== Chapitre 13 : S√©curit√© & Production (securite-production.adoc)

**Ajouts prioritaires** :

1. Section "Troubleshooting Production" avec cas r√©els :
   * Conteneurs qui ne d√©marrent pas
   * Health checks qui √©chouent
   * Logs de debugging Docker
2. Mettre √† jour SecureVote Phase 1 avec les bonnes pratiques (resolver, health checks)

**Temps estim√© de pr√©sentation** : +5 minutes

== Nouvel Exercice Pratique Sugg√©r√©

=== TP #11-BIS : Debugging Docker Networking & NGINX

**Objectifs p√©dagogiques** :

* Comprendre la diff√©rence entre localhost et nom de service
* Apprendre √† diagnostiquer les erreurs NGINX DNS
* Pratiquer le debugging de health checks

**√ânonc√©** :

Vous recevez un projet Docker avec NGINX + Application qui **ne fonctionne pas**. Le projet contient volontairement 3 erreurs :

1. NGINX manque la directive `resolver`
2. Health check utilise `curl` non install√©
3. Configuration de logging utilise `localhost` au lieu du nom de service

**√âtapes** :

1. Clonez le projet : `git clone https://gitlab.univ-artois.fr/bruno.verachten/docker-debug-tp.git`
+
[NOTE]
====
Pour une accessibilit√© maximale, envisagez de migrer ce projet vers GitHub/GitLab.com public pour les √©tudiants hors Universit√© d'Artois.
====
2. Lancez : `docker compose up -d`
3. Observez les √©checs : `docker ps` montre "Created" ou "unhealthy"
4. **Diagnostiquez** chaque probl√®me :
   * Utilisez `docker logs nginx`
   * Utilisez `docker inspect nginx`
   * Utilisez `docker events`
5. **Corrigez** les 3 erreurs
6. V√©rifiez : `curl http://localhost/` doit fonctionner

**Solution fournie** : Avec explications d√©taill√©es de chaque fix.

== Priorit√©s d'Impl√©mentation

[cols="1,3,2,1", options="header"]
|===
| Priorit√© | Modification | Chapitre | Impact

| üî¥ P0 (Critique)
| Ajouter section NGINX resolver
| reseaux.adoc
| Tr√®s √©lev√©

| üî¥ P0 (Critique)
| Ajouter section localhost vs service name
| reseaux.adoc
| Tr√®s √©lev√©

| üü° P1 (Haute)
| Ajouter section outils manquants health checks
| compose.adoc
| √âlev√©

| üü° P1 (Haute)
| Mettre √† jour SecureVote Phase 1 nginx.conf
| securite-production.adoc
| √âlev√©

| üü¢ P2 (Moyenne)
| Ajouter TP debugging
| Nouveau chapitre
| Moyen

| üü¢ P2 (Moyenne)
| Section Troubleshooting production
| securite-production.adoc
| Moyen
|===

== Conclusion

Ces am√©liorations combleront les **gaps critiques** identifi√©s dans l'examen 2025-2026 et permettront aux futurs √©tudiants d'√©viter des √©checs facilement pr√©venables.

**B√©n√©fices attendus** :

* ‚úÖ Moins d'√©checs sur des d√©tails techniques
* ‚úÖ Meilleure compr√©hension du r√©seau Docker
* ‚úÖ Projets plus robustes et production-ready
* ‚úÖ Notes globales am√©lior√©es

**Temps de cours additionnel** : ~30 minutes au total (r√©parti sur 3 chapitres)

**ROI p√©dagogique** : Tr√®s √©lev√© (transforme des F en C/D avec des changements minimes)
