= ğŸ‹ğŸ™ Docker compose

image::2073552164-image2.png[height=550px]

== ğŸŒğŸ¡ Un cas de la vraie vie

Une application riche repose souvent sur plusieurs Ã©lÃ©ments techniques Ã  coordonner ensemble.

(Apache, Tomcat, Node, MongoDB, ElasticSearch, Logstash, etc.)

Comment automatiser ces dÃ©ploiements ?

[%autoanimate]
== ğŸ“œğŸ’» On pourrait tout scripterâ€¦

[source,bash]
----
include::../code-samples/compose/script.sh[]
----

[%autoanimate]
== ğŸ“œğŸ’» Tout scripter

image::351794078-image3.gif[]

[%step]
- Et tout lancer indÃ©pendamment ?
- Et tout monitorer un par un ?
- Peut mieux faire, non ?

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
----
[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:

          
               
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
          
               
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----
[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
            
                
                  
  db:

----
[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
    image: "mysql:5.6"
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
    image: "mysql:5.6"
    ports:
      - "3306:3306"

----

[%auto-animate]
== ğŸ¤”â¡ï¸ Et aprÃ¨s ?

[source,bash]
----
docker compose up -d
docker compose build
docker compose logs
docker compose stop
docker compose restart
docker compose down
----

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

L'ordre de dÃ©marrage fait rÃ©fÃ©rence Ã  la sÃ©quence dans laquelle les services dÃ©finis dans un fichier Docker Compose sont lancÃ©s.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Pourquoi est-ce important ?
[%step]
Certains services peuvent dÃ©pendre d'autres services pour fonctionner correctement.
[%step]
Par exemple, une application web peut avoir besoin qu'une base de donnÃ©es soit opÃ©rationnelle avant de pouvoir dÃ©marrer.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Comment Docker Compose gÃ¨re-t-il l'ordre de dÃ©marrage ?
[%step]
Par dÃ©faut, Docker Compose dÃ©marre les services dans l'ordre dans lequel ils sont dÃ©finis dans le fichier Docker Compose.
[%step]
Cependant, cela ne garantit pas que les services dÃ©pendants seront prÃªts Ã  Ãªtre utilisÃ©s lorsque les services qui en dÃ©pendent seront lancÃ©s.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Comment gÃ©rer les dÃ©pendances entre services ?
[%step]
Docker Compose offre deux directives pour gÃ©rer les dÃ©pendances entre services : `depends_on` et `healthcheck`.

[%step]
- `depends_on` : Cette directive peut Ãªtre utilisÃ©e pour indiquer qu'un service dÃ©pend d'un autre service.
Cependant, cela ne garantit pas que le service dÃ©pendant sera prÃªt Ã  Ãªtre utilisÃ© lorsque le service qui en dÃ©pend sera lancÃ©.
- `healthcheck` : Cette directive peut Ãªtre utilisÃ©e pour vÃ©rifier l'Ã©tat de santÃ© d'un service.
En combinaison avec `depends_on`, elle peut aider Ã  s'assurer qu'un service est prÃªt Ã  Ãªtre utilisÃ© avant de lancer les services qui en dÃ©pendent.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Exemple
Voici un exemple de fichier Docker Compose qui utilise `depends_on` et `healthcheck` pour gÃ©rer l'ordre de dÃ©marrage des services :

[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 30s
      retries: 3
----

[%step]
Dans cet exemple, le service web dÃ©pend du service db.
Le service db est vÃ©rifiÃ© toutes les 30 secondes pour s'assurer qu'il est prÃªt Ã  Ãªtre utilisÃ©.
Le service web ne sera lancÃ© que lorsque le service db sera en bonne santÃ©.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrageâ“ğŸ¤” Conditions.

WARNING: Rappel:
La directive `depends_on` dans un fichier Docker Compose est utilisÃ©e pour indiquer qu'un service dÃ©pend d'un autre service.
Cela signifie que le service dÃ©pendant ne sera pas dÃ©marrÃ© tant que les services dont il dÃ©pend n'auront pas Ã©tÃ© dÃ©marrÃ©s.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrageâ“ğŸ¤” Autres conditions.

En plus de la condition service_healthy, il existe d'autres conditions que vous pouvez utiliser avec `depends_on`:
[%step]
`service_started` : Cette condition signifie que le service dÃ©pendant ne sera pas dÃ©marrÃ© tant que le service dont il dÃ©pend n'aura pas Ã©tÃ© dÃ©marrÃ©.
[%step]
`service_completed_successfully`: Cette condition indique qu'un service dÃ©pendant ne doit pas dÃ©marrer avant qu'un autre service ait terminÃ© avec succÃ¨s. Cela peut Ãªtre utile dans des scÃ©narios oÃ¹ un service doit effectuer une tÃ¢che unique qui doit Ãªtre terminÃ©e avant que d'autres services puissent dÃ©buter.
[%step]
Cependant, cela ne garantit pas que le service dont il dÃ©pend est prÃªt Ã  Ãªtre utilisÃ©.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrageâ“ğŸ¤” Autre condition.

Voici un exemple de comment vous pourriez utiliser `service_started` dans un fichier Docker Compose :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_started
  db:
    image: postgres
----

[%step]
Dans cet exemple, le service `web` ne sera dÃ©marrÃ© que lorsque le service `db` aura Ã©tÃ© dÃ©marrÃ©.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage & ğŸ©ºâœ… healthcheck

WARNING: Rappel
`healthcheck` est une instruction dans un `Dockerfile` qui permet de vÃ©rifier l'Ã©tat de santÃ© d'un service.
Il peut Ãªtre utilisÃ© pour dÃ©terminer si un service est prÃªt Ã  Ãªtre utilisÃ© ou non.
[%step]
Voici un exemple de `healthcheck` dans un `Dockerfile` :
[%step]
[source,dockerfile]
----
FROM postgres
HEALTHCHECK --interval=5m --timeout=3s \
  CMD pg_isready -U postgres || exit 1
----
[%step]
Dans cet exemple, `pg_isready -U postgres` est la commande utilisÃ©e pour vÃ©rifier l'Ã©tat de santÃ© du service.
Si cette commande rÃ©ussit, le service est considÃ©rÃ© comme sain.
Sinon, il est considÃ©rÃ© comme malsain.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage & ğŸ©ºâœ… healthcheck
WARNING: Rappel
`depends_on` est une directive dans un fichier Docker Compose qui indique qu'un service dÃ©pend d'un autre service.
Il peut Ãªtre utilisÃ© pour contrÃ´ler l'ordre de dÃ©marrage des services.
[%step]
Voici un exemple de depends_on dans un fichier Docker Compose :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
----
[%step]
Dans cet exemple, le service `web` dÃ©pend du service `db`.
Le service web ne sera dÃ©marrÃ© que lorsque le service db sera en bonne santÃ©.

[%auto-animate]
== ğŸğŸ”¢ ğŸ©ºâœ… Comment healthcheck et depends_on travaillent ensemble ?
[.title]
En combinant `healthcheck` et `depends_on`, vous pouvez contrÃ´ler l'ordre de dÃ©marrage des services en fonction de leur Ã©tat de santÃ©.
Par exemple, vous pouvez vous assurer qu'un service de base de donnÃ©es est prÃªt Ã  Ãªtre utilisÃ© avant de dÃ©marrer une application web qui en dÃ©pend.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage ğŸ“ŠğŸ“ Pour rÃ©sumer

L'ordre de dÃ©marrage fait rÃ©fÃ©rence Ã  la sÃ©quence dans laquelle les services dÃ©finis dans un fichier Docker Compose sont lancÃ©s.
Par dÃ©faut, Docker Compose dÃ©marre les services dans l'ordre dans lequel ils sont dÃ©finis dans le fichier Docker Compose.

[%step]
Docker Compose offre deux directives pour gÃ©rer les dÃ©pendances entre services : `depends_on` et `healthcheck`.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage ğŸ“ŠğŸ“ Pour rÃ©sumer

- `depends_on` : Cette directive peut Ãªtre utilisÃ©e pour indiquer qu'un service dÃ©pend d'un autre service. Elle peut Ãªtre utilisÃ©e avec deux conditions : `service_started` et `service_healthy`.
- `service_started` : Cette condition signifie que le service dÃ©pendant ne sera pas dÃ©marrÃ© tant que le service dont il dÃ©pend n'aura pas Ã©tÃ© dÃ©marrÃ©. Cependant, cela ne garantit pas que le service dont il dÃ©pend est prÃªt Ã  Ãªtre utilisÃ©.
- `service_healthy` : Cette condition est utilisÃ©e avec la directive healthcheck dans un Dockerfile pour vÃ©rifier l'Ã©tat de santÃ© d'un service. Si la commande healthcheck rÃ©ussit, Docker considÃ¨re le service comme sain. Sinon, il est considÃ©rÃ© comme malsain.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage ğŸ“ŠğŸ“ Pour rÃ©sumer
[.title]
Exemple
Voici un exemple de fichier Docker Compose qui utilise depends_on et healthcheck pour gÃ©rer l'ordre de dÃ©marrage des services :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 30s
      retries: 3
----

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

Un exemple de fichier docker-compose.yml utilisÃ© dans Jenkins:

https://raw.githubusercontent.com/ash-sxn/GSoC-2023-docker-based-quickstart/main/docker-compose.yaml

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
Les options `stdin_open: true` et `tty: true` sont utilisÃ©es pour garder l'entrÃ©e standard du conteneur ouverte et pour allouer un pseudo-TTY au conteneur, respectivement.
C'est gÃ©nÃ©ralement fait lorsque vous voulez interagir avec le service en cours d'exÃ©cution.

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----

-  La directive `entrypoint` est utilisÃ©e pour spÃ©cifier la commande qui sera exÃ©cutÃ©e lorsque le conteneur dÃ©marre.
- Dans ce cas, elle exÃ©cute une commande shell qui exÃ©cute un script nommÃ© `keygen.sh` situÃ© Ã  `/usr/local/bin/keygen.sh`.
- Le script reÃ§oit un argument `/ssh-dir`, qui est le rÃ©pertoire oÃ¹ le script effectuera ses opÃ©rations.

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
* La directive volumes est utilisÃ©e pour monter un volume nommÃ© `agent-ssh-dir` sur le chemin `/ssh-dir` Ã  l'intÃ©rieur du conteneur.
* Cela permet de conserver les donnÃ©es entre les redÃ©marrages du conteneur et peut Ã©galement Ãªtre utilisÃ© pour partager des donnÃ©es entre les conteneurs.

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
* Enfin, un healthcheck est dÃ©fini pour le service. Il s'agit d'une commande que Docker exÃ©cutera Ã  l'intÃ©rieur du conteneur pour vÃ©rifier sa santÃ©.
* Dans ce cas, la commande vÃ©rifie si un fichier nommÃ© `conductor_ok` existe dans le rÃ©pertoire `/ssh-dir`.
* Si le fichier existe, la commande rÃ©ussit et Docker considÃ¨re le service comme sain.
* Si le fichier n'existe pas, la commande Ã©choue et Docker considÃ¨re le service comme malsain.
* Docker exÃ©cutera cette vÃ©rification de santÃ© toutes les 5 secondes (`interval: 5s`), et si elle ne rÃ©pond pas dans les 10 secondes (`timeout: 10s`), Docker la considÃ©rera comme un Ã©chec. Docker rÃ©essaiera une vÃ©rification de santÃ© Ã©chouÃ©e 5 fois (`retries: 5`) avant de considÃ©rer le service comme malsain.

[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
* Service jenkins_controller
[%step]
** Ce service dÃ©pend du `sidekick_service`.
** Il ne dÃ©marrera que lorsque le `sidekick_service` aura terminÃ© avec succÃ¨s.
** C'est ce que signifie la condition `service_completed_successfully`.
--


[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Un `healthcheck` est Ã©galement dÃ©fini pour ce service.
[%step]
* Docker vÃ©rifie si un fichier nommÃ© `conductor_ok` existe dans le chemin `/ssh-dir`.
* Si le fichier existe, Docker considÃ¨re le service comme sain.
* Sinon, il est considÃ©rÃ© comme malsain.
--


[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Service `default_agent`
[%step]
* Ce service dÃ©pend Ã©galement du `sidekick_service` et du `jenkins_controller`.
* Il ne dÃ©marrera que lorsque le `sidekick_service` aura terminÃ© avec succÃ¨s et que le `jenkins_controller` aura dÃ©marrÃ©.
* C'est ce que signifient les conditions `service_completed_successfully` et `service_started`.
--

[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Un `healthcheck` est Ã©galement dÃ©fini pour ce service.
[%step]
* Docker vÃ©rifie si un fichier nommÃ© `authorized_keys` existe dans le chemin `/home/jenkins/.ssh`.
* Si le fichier existe, Docker considÃ¨re le service comme sain.
* Sinon, il est considÃ©rÃ© comme malsain.
--

[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Enfin, un volume nommÃ© `agent-ssh-dir` est montÃ© sur le chemin `/home/jenkins/.ssh` Ã  l'intÃ©rieur du conteneur en lecture seule.
--

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

Ã€ Ã©tudier au calme chez vous:

https://raw.githubusercontent.com/gounthar/MyFirstAndroidAppBuiltByJenkins/stf/jenkins/docker-compose.yml

image::47642838-image4.png[]

[.notes]
--
Dans le temps, on recommandait de faire un script qui attendait que le service soit dÃ©marrÃ© avant de continuer.
https://github.com/vishnubob/wait-for-it
--

== Transformer son application en docker compose

Deux approches diffÃ©rentes et complÃ©mentairesÂ :
[%step]
* https://www.composerize.com/
* https://github.com/jwilder/dockerize

== ğŸ“ Travaux pratiques #12

image::497269344-image5.png[]

https://gitlab.univ-artois.fr/bruno.verachten/devops-docker-tp12.git

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

Ã‡a vous dirait d'avoir votre propre forge Gitlab ?
[%step]
ğŸ˜ Non, et bien c'est parti quand mÃªme.
[%step]
* CrÃ©ez un nouveau fichier appelÃ© `docker-compose.yml`.
* Dans ce fichier, dÃ©finissez trois services : `gitlab`, `gitlab-runner-1` et `gitlab-runner-2`.
* Pour le service `gitlab`:
** utilisez l'image `gitlab/gitlab-ce:latest` (prÃ©fixÃ©e par le cache spÃ©cifique ILI)
** redÃ©marrez toujours le conteneur s'il s'arrÃªte,
** dÃ©finissez le nom d'hÃ´te sur `localhost`,
** dÃ©finissez l'URL externe sur `http://localhost` et exposez les ports `80`, `443` et `22`.

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS
[%step]
* Pour les services gitlab-runner-1 et gitlab-runner-2:
[%step]
** utilisez l'image `gitlab/gitlab-runner:latest` (prÃ©fixÃ©e par le cache spÃ©cifique ILI),
** redÃ©marrez toujours le conteneur s'il s'arrÃªte,
** dÃ©pendez du service gitlab et montez le socket Docker et le fichier de configuration de GitLab Runner.
[%step]
* CrÃ©ez des volumes pour:
[%step]
** les fichiers de configuration,
** les fichiers journaux
** et les fichiers de donnÃ©es de GitLab,
** ainsi que pour les fichiers de configuration de GitLab Runner.

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

Pas assez dÃ©taillÃ©? ğŸ˜¨
[%step]
* Ouvrez votre Ã©diteur de texte prÃ©fÃ©rÃ© et crÃ©ez un nouveau fichier.
* Nommez ce fichier `docker-compose.yml`.
* Commencez le fichier avec la ligne `services:` pour commencer Ã  dÃ©finir les services de votre application.
* Commencez Ã  dÃ©finir votre premier service en tapant `gitlab:` sur une nouvelle ligne. Ce sera le service pour votre serveur GitLab.
* Sous `gitlab:`, ajoutez les dÃ©tails de votre service.
[%step]
** Par exemple, `image: 'gitlab/gitlab-ce:latest'` pour spÃ©cifier l'image Docker Ã  utiliser pour ce service.

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

* Sous `gitlab:`, ajoutez les dÃ©tails de votre service.
** Par exemple, `image: 'gitlab/gitlab-ce:latest'` pour spÃ©cifier l'image Docker Ã  utiliser pour ce service.
** Continuez Ã  ajouter des dÃ©tails pour le service gitlab, comme `restart: always` pour toujours redÃ©marrer le conteneur s'il s'arrÃªte, et `hostname: 'localhost'` pour dÃ©finir le nom d'hÃ´te du serveur GitLab.
[%step]
* DÃ©finissez l'URL externe de votre serveur GitLab en ajoutant `environment:` et `GITLAB_OMNIBUS_CONFIG: |` sur de nouvelles lignes,
* puis `external_url 'http://localhost'` sur la ligne suivante.
* Exposez les ports nÃ©cessaires en ajoutant `ports:` sur une nouvelle ligne,
* puis `- '80:80'`, `- '443:443'` et `- '22:22'` sur les lignes suivantes.


[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

[%step]
* Montez les volumes nÃ©cessaires en ajoutant `volumes:` sur une nouvelle ligne,
[%step]
** puis `- 'gitlab_config:/etc/gitlab'`,
** `- 'gitlab_logs:/var/log/gitlab'`
** et `- 'gitlab_data:/var/opt/gitlab'` sur les lignes suivantes.
[%step]
* RÃ©pÃ©tez ces Ã©tapes pour les services gitlab-runner-1 et gitlab-runner-2, en remplaÃ§ant `gitlab` par `gitlab-runner-1` et `gitlab-runner-2` respectivement.


[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

[%step]
* Pour les services `gitlab-runner-1` et `gitlab-runner-2`, remplacez l'URL externe par une dÃ©pendance au service gitlab en ajoutant `depends_on:` sur une nouvelle ligne, puis `- gitlab` sur la ligne suivante.
* Montez le socket Docker et le fichier de configuration de GitLab Runner
[%step]
** en ajoutant `- '/var/run/docker.sock:/var/run/docker.sock'`
** et `- 'gitlab-runner-1-config:/etc/gitlab-runner'` (ou `- 'gitlab-runner-2-config:/etc/gitlab-runner'` pour `gitlab-runner-2`) sous `volumes:`.

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

[%step]
Enfin, dÃ©finissez les volumes pour votre application en ajoutant `volumes:` sur une nouvelle ligne Ã  la fin de votre fichier, puis
[%step]
** `- gitlab_config:`,
** `- gitlab_logs:`,
** `- gitlab_data:`,
** `- gitlab-runner-1-config:`
** et `- gitlab-runner-2-config:` sur les lignes suivantes.

== âœ… Solution Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

[source,yaml]
----
include::../code-samples/compose/tp12-bis.yml[]
----

[%auto-animate]
[.columns]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

[.column]
image::when.png[height=500px]
[.column]
video::gitlab-logs.speed.very.small.mp4[height=500px,options=autoplay,loop,nocontrols]

[%auto-animate]
[background-video="2000_years_later.mp4",background-video-loop=true,background-video-muted=true]
[.intellij.background]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

Il va falloir se logguer, lier les runners au serveur, crÃ©er un projet, etc...

[%auto-animate]
[.columns]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

[.column]
image::gitlab-login.png[height=500px]

[.column]
--
Pour trouver le mot de passe, il va falloir le demander gentiment Ã  Gitlab:

[source,bash]
----
docker compose -f tp12-bis.yml exec -it gitlab grep 'Password:' /etc/gitlab/initial_root_
password
Password: qaPxXU+RqioolV3bAljvs2VYnyYa4jO/UYcis/UXLAk=
----
[%step]
Ensuite, il va falloir restreindre l'accÃ¨s:
[%step]
image::sign-up-restrictions.png[]
--

[%auto-animate]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜
- Pour utiliser le runner GitLab dans GitLab, vous devez le configurer.
[%step]
- Pour une configuration correcte, nous aurons besoin d'un jeton copiÃ© depuis le portail.
- Pire que Ã§a, pas un jeton, mais carrÃ©ment une commande Ã  adapter Ã  `docker compose`.
- Pour ce faire, allez Ã  l'adresse : http://localhost/admin/runners et cliquez sur le bouton "New instance runner".
- Choisissez "Linux".
- "Run untagged jobs"
- Donnez une description au runner.
- Cliquez sur le bouton "Create runner"
- Vous avez ensuite une commande Ã  copier et modifier pour `docker compose`.


[%auto-animate]
[%notitle,background-iframe="https://www.youtube.com/embed/S-npLuur6KM?rel=0&start=0&enablejsapi=1&autoplay=1&loop=1&controls=1&modestbranding=1"]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

[.notes]
--
https://youtu.be/S-npLuur6KM
--

[%auto-animate]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

[source,bash]
----
docker compose -f tp12-bis.yml exec gitlab-runner-1 gitlab-runner register --url http://gitlab  --token glrt-PF5rLbUKzku5g8BL2y7J
Runtime platform                                    arch=amd64 os=linux pid=103 revision=853330f9 version=16.5.0
Running in system-mode.

Enter the GitLab instance URL (for example, https://gitlab.com/):
[http://gitlab]:
Verifying runner... is valid                        runner=PF5rLbUKz
Enter a name for the runner. This is stored only in the local config.toml file:
[3c2ee0d97d2b]: runner 1
Enter an executor: parallels, docker-autoscaler, docker+machine, custom, docker, docker-windows, shell, ssh, virtualbox, instance, kubernetes:
shell
Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded!

Configuration (with the authentication token) was saved in "/etc/gitlab-runner/config.toml"
----

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™
On a vu dÃ©jÃ  l'instruction `depends_on` dans un fichier Docker Compose.
[%step]
- Elle permet de dÃ©finir des dÃ©pendances entre les services.
- Mais que faire si on veut dÃ©finir un lot de services qui fonctionnent ensemble, sans pour autant Ãªtre en interdÃ©pendanceâ€¯?
- Les profils dans Docker Compose permettent de dÃ©finir des groupes de services qui peuvent Ãªtre activÃ©s ou dÃ©sactivÃ©s ensemble.
- Cela peut Ãªtre utile pour gÃ©rer des environnements de dÃ©veloppement, de test et de production diffÃ©rents dans le mÃªme fichier Docker Compose.
- Pour dÃ©finir un profil pour un service, vous pouvez ajouter la clÃ© `profiles` Ã  la dÃ©finition du service dans votre fichier Docker Compose.

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™
Par exemple :

[%step]
[source,yaml]
----
services:
  mon_service:
    image: mon_image
    profiles:
      - dev
----
[%step]
Dans cet exemple, le service mon_service appartient au profil dev.

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™

[%step]
- Pour dÃ©marrer seulement les services qui appartiennent Ã  un certain profil, vous pouvez utiliser l'option `--profile` avec la commande `docker-compose up`.
- Par exemple :

[%step]
[source,bash]
----
docker-compose up --profile dev
----
[%step]
Cette commande dÃ©marrera seulement les services qui appartiennent au profil `dev`.

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™

[%step]
- Les profils peuvent rendre votre fichier Docker Compose plus organisÃ© et flexible.
- Ils vous permettent de dÃ©finir diffÃ©rents environnements dans le mÃªme fichier et de choisir facilement quels services dÃ©marrer en fonction de vos besoins.
- Jetons un coup d'Å“il Ã  un exemple de fichier Docker Compose avec des profils :

[%step]
[source,yaml]
----
services:
  service_dev:
    image: mon_image_dev
    profiles:
      - dev
  service_prod:
    image: mon_image_prod
    profiles:
      - prod
----
[%step]
- Dans cet exemple, nous avons deux services : `service_dev` et `service_prod`.
- Chacun appartient Ã  un profil diffÃ©rent.

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™
[source,yaml]
----
services:
  service_dev:
    image: mon_image_dev
    profiles:
      - dev
  service_prod:
    image: mon_image_prod
    profiles:
      - prod
----
[%step]
- Nous pouvons choisir de dÃ©marrer seulement les services de dÃ©veloppement avec `docker-compose up --profile dev`, ou uniquement les services de production avec `docker-compose up --profile prod`.
- Les profils dans Docker Compose sont un outil puissant pour gÃ©rer diffÃ©rents environnements dans le mÃªme fichier Docker Compose.
- Ils peuvent rendre votre dÃ©veloppement et vos tests plus efficaces et organisÃ©s.

== ğŸ”¨ğŸ”¥ Une autre forge, Ã§a vous dit? ğŸ˜

[%step]
ğŸ˜ Non, et bien, c'est parti quand mÃªme.
[%step]

https://raw.githubusercontent.com/ash-sxn/GSoC-2023-docker-based-quickstart/main/build-docker-compose.yaml
[%step]
[source,yaml]
----
include::../code-samples/compose/jenkins-docker-compose.yml[]
----

== ğŸ”¨ğŸ”¥ Une autre forge, Ã§a vous dit? ğŸ˜

Indigeste? ğŸ˜¨
[%step]
Ne relevons que les points importants:

[%step]
[source,yaml]
----
  # Le service maven est un agent Jenkins avec Maven et le JDK installÃ©s.
  maven:
    build: dockerfiles/maven/.  # Le Dockerfile pour construire l'image du service Maven.
    container_name: desktop-jenkins_agent-1  # Le nom du conteneur.
    profiles:
      - maven  # Les profils Ã  appliquer au service. Cela permet de personnaliser le comportement du service en fonction des besoins spÃ©cifiques.
    depends_on:  # Les services dont ce service dÃ©pend.
      sidekick_service:
        condition: service_completed_successfully  # Le sidekick_service doit se terminer avec succÃ¨s avant que ce service ne dÃ©marre.
      jenkins_controller:
        condition: service_started  # Le service jenkins_controller doit dÃ©marrer avant que ce service ne dÃ©marre.
    healthcheck:  # La commande de vÃ©rification de santÃ© pour le service.
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # VÃ©rifie si le fichier authorized_keys existe dans le chemin /home/jenkins/.ssh.
      interval: 5s  # Le temps entre les vÃ©rifications de santÃ©.
      timeout: 10s  # Le temps Ã  attendre avant de considÃ©rer que la vÃ©rification a Ã©chouÃ©.
      retries: 5  # Le nombre d'Ã©checs consÃ©cutifs nÃ©cessaires pour considÃ©rer un service comme malsain.
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Monte le volume agent-ssh-dir au chemin /home/jenkins/.ssh Ã  l'intÃ©rieur du conteneur en lecture seule.
----

== Autre Ã©tude de cas ğŸ“šğŸ”

Et pourquoi pas s'attaquer au docker-compose qui a gÃ©nÃ©rÃ© ce coursâ€¯?
