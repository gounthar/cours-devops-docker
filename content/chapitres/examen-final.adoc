[{invert}]
== Projet de fin de module

[.title]
**DEVOPS M2 ILI - Ann√©e 2024-2025**

=== Modalit√©s : Travail en bin√¥me

* **Travail en bin√¥me** obligatoire
* **Choix de technologies** via vote Moodle

=== Modalit√©s : Remise du projet

* **Remise** : Repository GitLab **priv√©**
* Ajouter les enseignants comme **maintainers**
* **Documentation** : Tout dans le `README.md`

=== Modalit√©s : Date limite

[.title]
**8 janvier 2025**

Seuls les commits **avant cette date** seront √©valu√©s

=== Technologies : Reverse-Proxy

**Choisir 1 parmi :**

* Apache HTTPd
* Nginx
* Nginx Unit
* HAProxy
* Traefik

=== Technologies : Serveur d'Application

**Choisir 1 parmi :**

* Tomcat
* Wildfly
* Jetty

[{invert}]
== Partie 1 : Infrastructure & Containers

[.title]
**Votre partie - Not√©e sur 10 points**

**Crit√®res principaux + Compl√©ments valoris√©s**

=== Architecture cible

image::exam-architecture-diagram.png[Architecture, 800]

=== Architecture : Vue d'ensemble

* Architecture **production-ready** conteneuris√©e
* Support application Java EE
* Stack compl√®te : Reverse Proxy + App Server + Database + ELK
* D√©marrage : `docker compose up -d`

[{invert}]
== Exigences fonctionnelles

[.title]
**Partie obligatoire**

=== 1. Architecture multi-tiers (1/4)

**Reverse-proxy**

* Configur√© avec load-balancing
* Si plusieurs instances d'app

=== 1. Architecture multi-tiers (2/4)

**Serveur d'application**

* H√©bergeant votre WAR Java EE
* Correctement configur√©

=== 1. Architecture multi-tiers (3/4)

**Base de donn√©es**

* PostgreSQL **ou** MySQL
* Donn√©es **persistantes**

=== 1. Architecture multi-tiers (4/4)

**Stack ELK**

* Elasticsearch + Logstash + Kibana
* Pour centralisation des logs

=== 2. Docker Compose (1/4)

**Fichier compose.yml**

* Bien structur√©
* Lisible et maintenable

=== 2. Docker Compose (2/4)

**Variables d'environnement**

* Fichier `.env` pour la config
* `.env.example` committ√© (pas le .env!)

=== 2. Docker Compose (3/4)

**Networks Docker**

* Isolation appropri√©e des services
* Segmentation r√©seau

=== 2. Docker Compose (4/4)

**Volumes**

* Volumes **nomm√©s**
* Persistance des donn√©es

=== 3. Images Docker (1/4)

**Multi-stage builds**

* Quand c'est pertinent
* Images optimis√©es

=== 3. Images Docker (2/4)

**Taille d'image**

* < 500 MB pour l'app
* < 200 MB pour les services

=== 3. Images Docker (3/4)

**.dockerignore**

* Pr√©sents
* Bien configur√©s

=== 3. Images Docker (4/4)

**Pas de secrets dans les images**

* Utiliser build args
* Ou secrets Docker

[{invert}]
== Exigences qualit√©

[.title]
**Partie obligatoire**

=== 4. Health checks (1/3)

**Health checks Docker**

* Sur **tous** les services
* Correctement configur√©s

=== 4. Health checks (2/3)

**Restart policies**

* `on-failure` ou `unless-stopped`
* Selon le service

=== 4. Health checks (3/3)

**D√©pendances de d√©marrage**

* `depends_on` avec `condition: service_healthy`
* Temps total < 2 minutes

=== 5. Resource management

**Limites CPU et m√©moire**

* D√©finies sur chaque service
* Adapt√©es √† un environnement de d√©veloppement

=== 6. Logging (1/2)

**Format structur√©**

* Logs au format JSON quand possible
* Int√©gration avec Logstash

=== 6. Logging (2/2)

**Exploitabilit√©**

* Logs dans Kibana
* Filtres et dashboards de base

=== 7. S√©curit√© (1/3)

**Pas de root**

* Conteneurs applicatifs avec `USER` non-root
* Principe du moindre privil√®ge

=== 7. S√©curit√© (2/3)

**Gestion des secrets**

* Docker secrets ou variables d'environnement
* **Jamais** en clair dans le code

=== 7. S√©curit√© (3/3)

**Scanning de vuln√©rabilit√©s**

* Trivy sur l'image applicative
* Rapport g√©n√©r√©

=== 8. Documentation (1/3)

**README.md structur√©**

* Architecture (sch√©ma + explications)
* Pr√©requis et installation
* Configuration (variables)

=== 8. Documentation (2/3)

**README.md (suite)**

* Utilisation (commandes, URLs)
* R√©solution des probl√®mes courants

=== 8. Documentation (3/3)

**Justifications**

* Pourquoi ce reverse-proxy ?
* Pourquoi cette configuration ?
* Sch√©ma d'architecture (Mermaid/PlantUML/draw.io)

=== Grille d'√©valuation Partie 1

[cols="3,1,6"]
|===
|Crit√®re |Points |D√©tails

|Architecture fonctionnelle
|3 pts
|Stack compl√®te fonctionnelle, accessible

|Qualit√© technique
|3 pts
|Multi-stage, health checks, resources, s√©curit√©

|Documentation
|2 pts
|README complet avec sch√©ma et justifications

|Bonnes pratiques
|2 pts
|Images optimis√©es, logs structur√©s, secrets g√©r√©s

|**Total crit√®res**
|**10 pts**
|
|===

[{invert}]
== Compl√©ments valoris√©s : Allez plus loin !

[.title]
**Permettent de compenser et d'atteindre 10/10**

=== R√¥le des compl√©ments valoris√©s

[IMPORTANT]
====
* **Fonction** : Compenser les points manquants sur les crit√®res principaux
* **Formule** : Note Partie 1 = min(10, Crit√®res + Compl√©ments)
* **Objectif** : Atteindre 10/10 gr√¢ce √† des approfondissements
====

=== Strat√©gie recommand√©e

**Qualit√© > Quantit√©**

Il vaut mieux :

* 1-2 compl√©ments **de qualit√©**
* Que 4 compl√©ments **b√¢cl√©s**

Choisissez ce qui vous **int√©resse** !

=== Compl√©ment 1 : Observabilit√© (+1 pt) - Vue

**Prometheus + Grafana**

* Stack de monitoring moderne
* M√©triques temps r√©el

=== Compl√©ment 1 : Observabilit√© - D√©tails (1/3)

**Int√©gration**

* Prometheus pour collecter
* Grafana pour visualiser

=== Compl√©ment 1 : Observabilit√© - D√©tails (2/3)

**M√©triques custom**

* Expos√©es depuis votre application Java
* Via Micrometer par exemple

=== Compl√©ment 1 : Observabilit√© - D√©tails (3/3)

**Livrables attendus**

* **2 dashboards Grafana** (syst√®me + applicatif)
* **1 alerte** Prometheus minimum

=== Compl√©ment 1 : Ressources

* https://prometheus.io/docs/guides/cadvisor/[cAdvisor pour Docker]
* https://micrometer.io/[Micrometer pour Java]

=== Compl√©ment 2 : Pipeline validation (+1 pt) - Vue

**Tests automatiques du compose**

* Pipeline CI de validation
* Tests avec Goss

=== Compl√©ment 2 : Pipeline - D√©tails (1/2)

**Le pipeline doit :**

* Lancer `docker compose up -d`
* V√©rifier sant√© de tous les services
* Tester les endpoints critiques

=== Compl√©ment 2 : Pipeline - D√©tails (2/2)

**Objectif**

* G√©n√©rer un rapport de tests
* Valider les mises √† jour auto (Compl√©ment 3)

=== Compl√©ment 2 : Ressources

* https://github.com/goss-org/goss[Goss - Server testing]
* https://github.com/jenkinsci/docker/tree/master/tests[Tests Jenkins Docker]

=== Compl√©ment 3 : D√©pendances auto (+0.75 pt) - Vue

**Updatecli / Renovate / Dependabot**

* Mise √† jour automatique des d√©pendances
* Pull requests auto

=== Compl√©ment 3 : D√©pendances - D√©tails

**Configuration pour surveiller :**

* Images Docker de base
* D√©pendances Maven/Gradle
* Versions dans `compose.yml`

=== Compl√©ment 3 : Ressources

* https://updatecli.io/[Updatecli]
* https://docs.renovatebot.com/[Renovate]

=== Compl√©ment 4 : Load Testing (+1 pt) - Vue

**k6 ou Gatling**

* Tests de charge
* Optimisations prouv√©es

=== Compl√©ment 4 : Load Testing - D√©tails (1/2)

**Sc√©narios r√©alistes**

* Connexion utilisateur
* Op√©rations CRUD
* Charge progressive

=== Compl√©ment 4 : Load Testing - D√©tails (2/2)

**Rapport de performance**

* Throughput (req/s)
* Latence (p50, p95, p99)
* Taux d'erreur
* **Avant/apr√®s** optimisations

=== Compl√©ment 4 : Ressources

* https://k6.io/docs/[k6]
* https://gatling.io/docs/gatling/[Gatling]

=== Compl√©ment 5 : Haute disponibilit√© (+1 pt) - Vue

**Plusieurs instances + Load balancing**

* Au moins 2 instances d'app
* Zero-downtime deployment

=== Compl√©ment 5 : HA - D√©tails (1/2)

**Configuration**

* Multiple instances du serveur d'app
* Load balancing sur le reverse-proxy

=== Compl√©ment 5 : HA - D√©tails (2/2)

**D√©monstration**

* Script de rolling deployment
* Aucune requ√™te en erreur
* Optionnel : Chaos engineering (Pumba)

=== Compl√©ment 5 : Ressources

* https://github.com/alexei-led/pumba[Pumba - Chaos testing]

=== Compl√©ment 6 : Multi-environnements (+0.75 pt) - Vue

**Dev / Staging / Prod**

* 3 configurations
* Compose overrides

=== Compl√©ment 6 : Multi-env - D√©tails (1/2)

**Fichiers Compose**

* `compose.yml` (base commune)
* `compose.override.yml` (dev)
* `compose.prod.yml` (prod)

=== Compl√©ment 6 : Multi-env - D√©tails (2/2)

**Variables par environnement**

* `.env.dev`, `.env.staging`, `.env.prod`
* Documentation des diff√©rences

=== Compl√©ment 6 : Ressources

* https://docs.docker.com/compose/multiple-compose-files/[Compose inheritance]

=== Compl√©ment 7 : GitLab auto-h√©berg√© (+1.5 pts) - Vue

**Votre propre forge GitLab**

* GitLab CE en Docker Compose
* Maintenu √† jour automatiquement

=== Compl√©ment 7 : GitLab - D√©tails (1/2)

**Configuration**

* GitLab CE en Free-Tier
* Infrastructure as Code
* Updatecli pour les mises √† jour

=== Compl√©ment 7 : GitLab - D√©tails (2/2)

**Utilisation**

* Projet Partie 1 dans cette forge
* Optionnel : GitLab Runner pour Partie 2

=== Compl√©ment 7 : Ressources

* https://docs.gitlab.com/ee/install/docker.html[GitLab Docker]
* https://docs.gitlab.com/runner/install/docker.html[GitLab Runner]

[{invert}]
== Partie 2 : CI/CD avec GitLab

[.title]
**Partie de votre coll√®gue - Not√©e sur 10 points**

=== Code base

* **Fork** de l'application starter (alpha ou beta)
* Application **compl√®te**
* Enseignants en **maintainers**

=== Infrastructure Univ. Artois

[source,yaml]
----
nexus_mirror: http://nexus.etu-k8s.lan/repository/maven-public/
runner: k8s-etu
registry: registry.etu-k8s.lan/docker-hub/
sonarqube: http://sonarqube.univ-artois.fr
----

=== Git-flow

image::gitflow-diagram.png[Git-flow, 600]

=== Branches Git-flow

* `main` : production
* `develop` : int√©gration
* `feature/*` : nouvelles fonctionnalit√©s
* `release/*` : pr√©paration release
* `hotfix/*` : corrections urgentes

=== Pipeline 1 : CI - D√©clenchement

**Push sur n'importe quelle branche**

=== Pipeline 1 : CI - BUILD

[cols="3,1,1"]
|===
|Job |Failure? |Artefact?

|Build Java 21
|‚ùå Non
|‚ùå Non

|Build Java 11
|‚úÖ Oui
|‚ùå Non
|===

=== Pipeline 1 : CI - TEST

[cols="3,1,1"]
|===
|Job |Failure? |Artefact?

|Tests unitaires + Jacoco
|‚ùå Non
|‚úÖ 5min

|Analyse Trivy (HTML)
|‚ùå Non
|‚úÖ 5min
|===

=== Pipeline 1 : CI - QUALITY

[cols="3,1,1"]
|===
|Job |Failure? |Artefact?

|SonarQube
|‚úÖ Oui
|‚ùå Non

|JavaDoc
|‚úÖ Oui
|‚úÖ 5min
|===

=== Pipeline 2 : CD - D√©clenchement

**Merge Request vers `develop`**

=== Pipeline 2 : CD - BUILD-QUALIF

[cols="3,1,1"]
|===
|Job |Failure? |Artefact?

|Build Java 21
|‚ùå Non
|‚úÖ 5min
|===

=== Pipeline 3 : Delivery - D√©clenchement

**MR valid√©e : `develop` ‚Üí `main`**

=== Pipeline 3 : Delivery - Jobs (1/2)

[cols="3,1,1"]
|===
|Job |Failure? |Artefact?

|BUILD-PROD
|‚ùå Non
|‚úÖ 5min

|RELEASE-TAG
|‚ùå Non
|‚ùå Non
|===

=== Pipeline 3 : Delivery - Jobs (2/2)

[cols="3,1,1"]
|===
|Job |Failure? |Artefact?

|DELIVERY (Nexus) ‚≠ê
|‚ùå Non
|üéÅ BONUS
|===

Credentials : `m2ili` / `NexusM2ILI`

[{invert}]
== Communication

[.title]
**Bonnes pratiques**

=== Workflow : Merge Requests

[quote]
____
"Faites des **Merge Requests** et **mettez-moi en reviewer**.

Commit direct sur `main` ‚Üí je ne suis pas notifi√© !"
____

=== Ce qu'on attend

* Communication via **MR et issues**
* **Commits atomiques** (conventional commits)
* Documentation **√† jour** au fur et √† mesure
* Tests **avant** de merge
* **Demander de l'aide** si besoin !

[{invert}]
== Conseils pratiques

=== Par o√π commencer ? (1/4)

**1. Choisir les technologies**

* Vote Moodle
* Cr√©er le repo GitLab

=== Par o√π commencer ? (2/4)

**2. Partie 1 - It√©ratif**

* Docker Compose basique qui marche
* Puis health checks
* Puis optimisations
* Bonus si temps disponible

=== Par o√π commencer ? (3/4)

**3. Partie 2 - Progressif**

* Pipeline Integration d'abord
* Puis Deployment
* Puis Delivery

=== Par o√π commencer ? (4/4)

**4. Documentation**

* **Au fur et √† mesure**
* Pas √† la fin !

=== Ressources (1/2)

* https://docs.docker.com/[Docker officiel]
* https://github.com/docker/awesome-compose[Compose samples]
* https://docs.gitlab.com/ee/ci/[GitLab CI/CD]

=== Ressources (2/2)

* **Votre cours** : tout est dedans !
* **IA (ChatGPT/Claude)** : OK pour comprendre

[WARNING]
====
**Pas de plagiat !** On reconna√Æt le code IA sans compr√©hension.

Utilisez pour **apprendre**, pas pour **√©viter de r√©fl√©chir**.
====

=== Erreurs courantes (1/2)

* ‚ùå Secrets dans Git (`.env`)
* ‚ùå Images trop grosses
* ‚ùå Pas de health checks

=== Erreurs courantes (2/2)

* ‚ùå Volumes anonymes
* ‚ùå Tout en `root`
* ‚ùå Documentation absente

[{invert}]
== Grille d'√©valuation

=== Note finale : Vue d'ensemble

**Chaque partie not√©e sur 10**

* Partie 1 (vous) : /10
* Partie 2 (coll√®gue) : /10

Puis addition ‚Üí note finale /20

=== Partie 1 : Crit√®res principaux (10 pts)

[cols="2,1"]
|===
|Crit√®re |Points

|Architecture fonctionnelle
|3 pts

|Qualit√© technique
|3 pts

|Documentation
|2 pts

|Bonnes pratiques
|2 pts

|**Total**
|**10 pts**
|===

=== Partie 1 : Compl√©ments valoris√©s

[cols="2,1"]
|===
|Compl√©ment |Points

|Observabilit√©
|1 pt

|Pipeline validation
|1 pt

|D√©pendances auto
|0.75 pt

|Load Testing
|1 pt

|Haute disponibilit√©
|1 pt

|Multi-environnements
|0.75 pt

|GitLab auto-h√©berg√©
|1.5 pts
|===

=== Partie 1 : Calcul de la note

[IMPORTANT]
====
**Formule :** Note Partie 1 = min(10, Crit√®res + Compl√©ments)
====

[cols="2,1"]
|===
|Cat√©gorie |Points

|Crit√®res principaux
|10 pts max

|Compl√©ments valoris√©s
|Compensent les points manquants

|**TOTAL PARTIE 1**
|**10/10**
|===

=== Explication du m√©canisme

**R√¥le des compl√©ments :** Compenser les points perdus sur les crit√®res principaux

**Exemple 1 :** 7/10 crit√®res + 2 pts compl√©ments = 9/10 final

**Exemple 2 :** 8/10 crit√®res + 3 pts compl√©ments = 10/10 final (plafonn√©)

‚Üí Les compl√©ments permettent d'atteindre 10/10

[{invert}]
== Vos contacts

=== Enseignants

**Daniel Le Berre** - Partie 2 (CI/CD)

**Bruno Verachten** - Partie 1 (Infrastructure)

**Farid Ait-Kara**

[{invert}]
== Bon courage ! üöÄ

L'objectif : vous **pr√©parer** √† l'entreprise

Pas vous **pi√©ger** !

**Amusez-vous bien !**
