[{invert}]
= Docker Images

image::multi-layered-cake.jpeg[width=900]

== ğŸ¤” Pourquoi des images ?

* Un *conteneur* est toujours exÃ©cutÃ© depuis une *image*.
* Une *image de conteneur* (ou "Image Docker") est un  modÃ¨le ("template") d'application auto-suffisant.

=> Permet de fournir un livrable portable (ou presque).

[%auto-animate]
== ğŸ¤” C'est quoi une image ?

C'est une collection de fichiers et de metadonnÃ©es.

== ğŸ¤” C'est quoi une image ?

C'est une collection de fichiers et de metadonnÃ©es.

C'est une suite de couches superposÃ©es.

== ğŸ¤” C'est quoi une image ?

C'est une collection de fichiers et de metadonnÃ©es.

C'est une suite de couches superposÃ©es.

image::images-output5_with_transparency.png[]

[%auto-animate]
== ğŸ¤” C'est quoi une image ?

C'est une collection de fichiers et de metadonnÃ©es.

C'est une suite de couches superposÃ©es.

image::images-output6_with_transparency.png[]

[%auto-animate]
== ğŸ° DÃ©tail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output8_with_transparency.png[]

[%auto-animate]
== ğŸ° DÃ©tail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output9_with_transparency.png[]

[%auto-animate]
== ğŸ° DÃ©tail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output10_with_transparency.png[]

[%auto-animate]
== ğŸ° DÃ©tail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output11_with_transparency.png[]

[%auto-animate]
== ğŸ° DÃ©tail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output12_with_transparency.png[]

[%auto-animate]
== ğŸ° DÃ©tail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output13_with_transparency.png[]

[.notes]
--
[source,bash]
----
for i in {8..13}; do convert Diapositive${i}.PNG -crop 10221x4830+1556+2420 -transparent white -resize x1080 images-output${i}_with_transparency.png; done
----
--

== Dicton du jour

**__"L'image est Ã  la classe ce que le container est Ã  l'objet"__**

image::dicton-du-jour.png[]

== !

ğŸ¤” Application Auto-Suffisante ?

image::docker-app-self-sufficient.png[width=900]

== C'est quoi le principe ?

image::dockerfile-flow.png[]

[%auto-animate]
== ğŸ‹ Le livre de recettes

image::dockerfile.png[]

[%auto-animate]
== ğŸ‹ Le livre de recettes

image::dockerfile.png[]

[%auto-animate]
== ğŸ‹ Le livre de recettes

image::dockerfile.png[]

Un simple fichier nommÃ© "Dockerfile" (majuscule sur le D et pas d'extension).

[%auto-animate]
== ğŸ‹ Le livre de recettes

image::dockerfile.png[]

Un simple fichier nommÃ© "Dockerfile" (majuscule sur le D et pas d'extension).

C'est du texte, trÃ¨s pratique Ã  stocker dans Git.

[%auto-animate]
== ğŸ‹ Le livre de recettes

image::dockerfile.png[]

Un simple fichier nommÃ© "Dockerfile" (majuscule sur le D et pas d'extension).

C'est du texte, trÃ¨s pratique Ã  stocker dans Git.

Une suite de clÃ©-valeur.

== ğŸ¤” Pourquoi fabriquer sa propre image ?

â—ï¸ ProblÃ¨me :

[source,bash]
----
cat /etc/os-release
# ...
git --version
# ...

# MÃªme version de Linux que dans GitPod
docker container run --rm ubuntu:20.04 git --version
# docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: "git": executable file not found in $PATH: unknown.

# En interactif ?
docker container run --rm --tty --interactive ubuntu:20.04 git --version
----

== ğŸ“ Fabriquer sa premiÃ¨re image

* *But :* fabriquer une image Docker qui contient `git`

* Dans votre workspace Gitpod, crÃ©ez un dossier nommÃ© `docker-git/`
* Dans ce dossier, crÃ©er un fichier `Dockerfile` avec le contenu ci-dessous :
+
[source,Dockerfile]
----
FROM ubuntu:20.04
RUN apt-get update && apt-get install --yes --no-install-recommends git
----

* Fabriquez votre image avec la commande `docker image build --tag=docker-git <chemin/vers/docker-git/`

* Testez l'image fraÃ®chement fabriquÃ©e
** ğŸ’¡ `docker image ls`

== âœ… Fabriquer sa premiÃ¨re image

[source,bash]
----
cat <<EOF >Dockerfile
FROM ubuntu:20.04
RUN apt-get update && apt-get install --yes --no-install-recommends git
EOF

docker image build --tag=docker-git ./

docker image ls | grep docker-git

# Doit fonctionner
docker container run --rm docker-git:latest git --version
----

== Conventions de nommage des images

[source, plaintext]
----
[REGISTRY/][NAMESPACE/]NAME[:TAG|@DIGEST]
----

* Pas de Registre ? DÃ©faut: `registry.docker.com`
* Pas de Namespace ? DÃ©faut: `library`
* Pas de tag ? Valeur par dÃ©faut: `latest`
** âš ï¸ Friends don't let friends use `latest`
* Digest: signature unique basÃ©e sur le contenu

== Conventions de nommage : Exemples

* `ubuntu:20.04` => `registry.docker.com/library/ubuntu:20.04`
* `dduportal/docker-asciidoctor` => `registry.docker.com/dduportal/docker-asciidoctor:latest`
* `ghcr.io/dduportal/docker-asciidoctor:1.3.2@sha256:xxxx`

== ğŸ“ Utilisons les tags

* Rappel : âš ï¸ Friends don't let friends use `latest`

* Il est temps de "taguer" votre premiÃ¨re image !
+
[source,bash]
----
docker image tag docker-git:latest docker-git:1.0.0
----

* Testez le fonctionnement avec le nouveau tag
* Comparez les 2 images dans la sortie de `docker image ls`

== âœ… Utilisons les tags

[source,bash]
----
docker image tag docker-git:latest docker-git:1.0.0

# 2 lignes
docker image ls | grep docker-git
# 1 ligne
docker image ls | grep docker-git | grep latest
# 1 ligne
docker image ls | grep docker-git | grep '1.0.0'

# Doit fonctionner
docker container run --rm docker-git:1.0.0 git --version
----

== ğŸ“ Mettre Ã  jour votre image (1.1.0)

* Mettez Ã  jour votre image en version `1.1.0` avec les changements suivants :
** Ajoutez un https://docs.docker.com/engine/reference/builder/#label[`LABEL`,window="_blank"] dont la clef est `description` (et la valeur de votre choix)
** Configurez `git` pour utiliser une branche `main` par dÃ©faut au lieu de `master` (commande `git config --global init.defaultBranch main`)

* Indices :
** ğŸ’¡ Commande `docker image inspect <image name>`
** ğŸ’¡ Commande `git config --get init.defaultBranch` (dans le conteneur)
** ğŸ’¡ Ajoutez des lignes *Ã  la fin* du `Dockerfile`
** ğŸ’¡ https://docs.docker.com/engine/reference/builder/[Documentation de rÃ©fÃ©rence des `Dockerfile`,window="_blank"]

== âœ… Mettre Ã  jour votre image (1.1.0)

[source,bash]
----
cat ./Dockerfile
FROM ubuntu:20.04
RUN apt-get update && apt-get install --yes --no-install-recommends git
LABEL description="Une image contenant git prÃ©configurÃ©"
RUN git config --global init.defaultBranch main

docker image build -t docker-git:1.1.0 ./docker-git/
# Sending build context to Docker daemon  2.048kB
# Step 1/4 : FROM ubuntu:20.04
#  ---> e40cf56b4be3
# Step 2/4 : RUN apt-get update && apt-get install --yes --no-install-recommends git
#  ---> Using cache
#  ---> 926b8d87f128
# Step 3/4 : LABEL description="Une image contenant git prÃ©configurÃ©"
#  ---> Running in 0695fc62ecc8
# Removing intermediate container 0695fc62ecc8
#  ---> 68c7d4fb8c88
# Step 4/4 : RUN git config --global init.defaultBranch main
#  ---> Running in 7fb54ecf4070
# Removing intermediate container 7fb54ecf4070
#  ---> 2858ff394edb
Successfully built 2858ff394edb
Successfully tagged docker-git:1.1.0

docker container run --rm docker-git:1.0.0 git config --get init.defaultBranch
docker container run --rm docker-git:1.1.0 git config --get init.defaultBranch
# main
----

== Cache d'images & Layers

[source, plaintext]
----
Step 2/4 : RUN apt-get update && apt-get install --yes --no-install-recommends git
  ---> Using cache
----

ğŸ¤” En fait, Docker n'a PAS exÃ©cutÃ© cette commande la seconde fois => Ã§a va beaucoup plus vite !

image::docker-layers.jpg[width=400]

ğŸ“ Essayez de voir les layers avec (dans Gitpod) https://github.com/wagoodman/dive[`dive <image>:<tag>`,window="_blank"]

== ğŸ“ Cache d'images & Layers

* *But :* manipuler le cache d'images

* Commencez par vÃ©rifier que le cache est utilisÃ© : relancez la derniÃ¨re commande `docker image build` (plusieurs fois s'il le faut)

* Invalidez le cache en ajoutant le paquet APT `make` Ã  installer en mÃªme temps que `git`
** âš ï¸ Tag `1.2.0`

* VÃ©rifiez que le cache est bien prÃ©sent de nouveau

== âœ… Cache d'images & Layers

[source,bash]
----
# Build one time
docker image build -t docker-git:1.1.0 ./docker-git/
# Second time is fully cached
docker image build -t docker-git:1.1.0 ./docker-git/

cat Dockerfile
# FROM ubuntu:20.04
# RUN apt-get update && apt-get install --yes --no-install-recommends git make
# LABEL description="Une image contenant git prÃ©configurÃ©"
# RUN git config --global init.defaultBranch main

# Build one time
docker image build -t docker-git:1.2.0 ./docker-git/
# Second time is fully cached
docker image build -t docker-git:1.2.0 ./docker-git/

## VÃ©rification
# Renvoie une erreur
docker run --rm docker-git:1.1.0 make --version
# Doit fonctionner
docker run --rm docker-git:1.2.0 make --version
----

== Checkpoint ğŸ¯

* Une image Docker fournit un environnement de systÃ¨me de fichier auto-suffisant (application, dÃ©pendances, binaries, etc.) comme modÃ¨le de base d'un conteneur

* Les images Docker ont une convention de nommage permettant d'identifier les images trÃ¨s prÃ©cisÃ©ment

* On peut spÃ©cifier une recette de fabrication d'image Ã  l'aide d'un `Dockerfile` et de la commande `docker image build`

=> ğŸ¤” et si on utilisait Docker pour nous aider dans l'intÃ©gration continue ?
