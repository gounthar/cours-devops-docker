= ğŸ‹ğŸ™ Docker compose

image::2073552164-image2.png[height=550px]

== ğŸŒğŸ¡ Un cas de la vraie vie

Une application riche repose souvent sur plusieurs Ã©lÃ©ments techniques Ã  coordonner ensemble.

(Apache, Tomcat, Node, MongoDB, ElasticSearch, Logstash, etc.)

Comment automatiser ces dÃ©ploiements ?

[%autoanimate]
== ğŸ“œğŸ’» On pourrait tout scripterâ€¦

[source,bash]
----
include::../code-samples/compose/script.sh[]
----

[%autoanimate]
== ğŸ“œğŸ’» Tout scripter

image::351794078-image3.gif[]

[%step]
- Et tout lancer indÃ©pendamment ?
- Et tout monitorer un par un ?
- Peut mieux faire, non ?

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
----
[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:

          
               
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
          
               
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----
[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
            
                
                  
  db:

----
[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
                
                  
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
    image: "mysql:5.6"
----

[%autoanimate]
== ğŸ‹ğŸ™ docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
    image: "mysql:5.6"
    ports:
      - "3306:3306"

----

[%auto-animate]
== ğŸ¤”â¡ï¸ Et aprÃ¨s ?

[source,bash]
----
docker compose up -d
docker compose build
docker compose logs
docker compose stop
docker compose restart
docker compose down
----

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

L'ordre de dÃ©marrage fait rÃ©fÃ©rence Ã  la sÃ©quence dans laquelle les services dÃ©finis dans un fichier Docker Compose sont lancÃ©s.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Pourquoi est-ce important ?
[%step]
Certains services peuvent dÃ©pendre d'autres services pour fonctionner correctement.
[%step]
Par exemple, une application web peut avoir besoin qu'une base de donnÃ©es soit opÃ©rationnelle avant de pouvoir dÃ©marrer.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Comment Docker Compose gÃ¨re-t-il l'ordre de dÃ©marrage ?
[%step]
Par dÃ©faut, Docker Compose dÃ©marre les services dans l'ordre dans lequel ils sont dÃ©finis dans le fichier Docker Compose.
[%step]
Cependant, cela ne garantit pas que les services dÃ©pendants seront prÃªts Ã  Ãªtre utilisÃ©s lorsque les services qui en dÃ©pendent seront lancÃ©s.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Comment gÃ©rer les dÃ©pendances entre services ?
[%step]
Docker Compose offre deux directives pour gÃ©rer les dÃ©pendances entre services : `depends_on` et `healthcheck`.

[%step]
- `depends_on` : Cette directive peut Ãªtre utilisÃ©e pour indiquer qu'un service dÃ©pend d'un autre service.
Cependant, cela ne garantit pas que le service dÃ©pendant sera prÃªt Ã  Ãªtre utilisÃ© lorsque le service qui en dÃ©pend sera lancÃ©.
- `healthcheck` : Cette directive peut Ãªtre utilisÃ©e pour vÃ©rifier l'Ã©tat de santÃ© d'un service.
En combinaison avec `depends_on`, elle peut aider Ã  s'assurer qu'un service est prÃªt Ã  Ãªtre utilisÃ© avant de lancer les services qui en dÃ©pendent.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage

[.title]
Exemple
Voici un exemple de fichier Docker Compose qui utilise `depends_on` et `healthcheck` pour gÃ©rer l'ordre de dÃ©marrage des services :

[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 30s
      retries: 3
----

[%step]
Dans cet exemple, le service web dÃ©pend du service db.
Le service db est vÃ©rifiÃ© toutes les 30 secondes pour s'assurer qu'il est prÃªt Ã  Ãªtre utilisÃ©.
Le service web ne sera lancÃ© que lorsque le service db sera en bonne santÃ©.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrageâ“ğŸ¤” Conditions.

WARNING: Rappel:
La directive `depends_on` dans un fichier Docker Compose est utilisÃ©e pour indiquer qu'un service dÃ©pend d'un autre service.
Cela signifie que le service dÃ©pendant ne sera pas dÃ©marrÃ© tant que les services dont il dÃ©pend n'auront pas Ã©tÃ© dÃ©marrÃ©s.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrageâ“ğŸ¤” Autres conditions.

En plus de la condition service_healthy, il existe d'autres conditions que vous pouvez utiliser avec `depends_on`:
[%step]
`service_started` : Cette condition signifie que le service dÃ©pendant ne sera pas dÃ©marrÃ© tant que le service dont il dÃ©pend n'aura pas Ã©tÃ© dÃ©marrÃ©.
[%step]
`service_completed_successfully`: Cette condition indique qu'un service dÃ©pendant ne doit pas dÃ©marrer avant qu'un autre service ait terminÃ© avec succÃ¨s. Cela peut Ãªtre utile dans des scÃ©narios oÃ¹ un service doit effectuer une tÃ¢che unique qui doit Ãªtre terminÃ©e avant que d'autres services puissent dÃ©buter.
[%step]
Cependant, cela ne garantit pas que le service dont il dÃ©pend est prÃªt Ã  Ãªtre utilisÃ©.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrageâ“ğŸ¤” Autre condition.

Voici un exemple de comment vous pourriez utiliser `service_started` dans un fichier Docker Compose :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_started
  db:
    image: postgres
----

[%step]
Dans cet exemple, le service `web` ne sera dÃ©marrÃ© que lorsque le service `db` aura Ã©tÃ© dÃ©marrÃ©.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage & ğŸ©ºâœ… healthcheck

WARNING: Rappel
`healthcheck` est une instruction dans un `Dockerfile` qui permet de vÃ©rifier l'Ã©tat de santÃ© d'un service.
Il peut Ãªtre utilisÃ© pour dÃ©terminer si un service est prÃªt Ã  Ãªtre utilisÃ© ou non.
[%step]
Voici un exemple de `healthcheck` dans un `Dockerfile` :
[%step]
[source,dockerfile]
----
FROM postgres
HEALTHCHECK --interval=5m --timeout=3s \
  CMD pg_isready -U postgres || exit 1
----
[%step]
Dans cet exemple, `pg_isready -U postgres` est la commande utilisÃ©e pour vÃ©rifier l'Ã©tat de santÃ© du service.
Si cette commande rÃ©ussit, le service est considÃ©rÃ© comme sain.
Sinon, il est considÃ©rÃ© comme malsain.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage & ğŸ©ºâœ… healthcheck
WARNING: Rappel
`depends_on` est une directive dans un fichier Docker Compose qui indique qu'un service dÃ©pend d'un autre service.
Il peut Ãªtre utilisÃ© pour contrÃ´ler l'ordre de dÃ©marrage des services.
[%step]
Voici un exemple de depends_on dans un fichier Docker Compose :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
----
[%step]
Dans cet exemple, le service `web` dÃ©pend du service `db`.
Le service web ne sera dÃ©marrÃ© que lorsque le service db sera en bonne santÃ©.

[%auto-animate]
== ğŸğŸ”¢ ğŸ©ºâœ… Comment healthcheck et depends_on travaillent ensemble ?
[.title]
En combinant `healthcheck` et `depends_on`, vous pouvez contrÃ´ler l'ordre de dÃ©marrage des services en fonction de leur Ã©tat de santÃ©.
Par exemple, vous pouvez vous assurer qu'un service de base de donnÃ©es est prÃªt Ã  Ãªtre utilisÃ© avant de dÃ©marrer une application web qui en dÃ©pend.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage ğŸ“ŠğŸ“ Pour rÃ©sumer

L'ordre de dÃ©marrage fait rÃ©fÃ©rence Ã  la sÃ©quence dans laquelle les services dÃ©finis dans un fichier Docker Compose sont lancÃ©s.
Par dÃ©faut, Docker Compose dÃ©marre les services dans l'ordre dans lequel ils sont dÃ©finis dans le fichier Docker Compose.

[%step]
Docker Compose offre deux directives pour gÃ©rer les dÃ©pendances entre services : `depends_on` et `healthcheck`.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage ğŸ“ŠğŸ“ Pour rÃ©sumer

- `depends_on` : Cette directive peut Ãªtre utilisÃ©e pour indiquer qu'un service dÃ©pend d'un autre service. Elle peut Ãªtre utilisÃ©e avec deux conditions : `service_started` et `service_healthy`.
- `service_started` : Cette condition signifie que le service dÃ©pendant ne sera pas dÃ©marrÃ© tant que le service dont il dÃ©pend n'aura pas Ã©tÃ© dÃ©marrÃ©. Cependant, cela ne garantit pas que le service dont il dÃ©pend est prÃªt Ã  Ãªtre utilisÃ©.
- `service_healthy` : Cette condition est utilisÃ©e avec la directive healthcheck dans un Dockerfile pour vÃ©rifier l'Ã©tat de santÃ© d'un service. Si la commande healthcheck rÃ©ussit, Docker considÃ¨re le service comme sain. Sinon, il est considÃ©rÃ© comme malsain.

[%auto-animate]
== ğŸğŸ”¢ Ordre de dÃ©marrage ğŸ“ŠğŸ“ Pour rÃ©sumer
[.title]
Exemple
Voici un exemple de fichier Docker Compose qui utilise depends_on et healthcheck pour gÃ©rer l'ordre de dÃ©marrage des services :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 30s
      retries: 3
----

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

Un exemple de fichier docker-compose.yml utilisÃ© dans Jenkins:

https://raw.githubusercontent.com/jenkins-docs/quickstart-tutorials/refs/heads/main/docker-compose.yaml

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
Les options `stdin_open: true` et `tty: true` sont utilisÃ©es pour garder l'entrÃ©e standard du conteneur ouverte et pour allouer un pseudo-TTY au conteneur, respectivement.
C'est gÃ©nÃ©ralement fait lorsque vous voulez interagir avec le service en cours d'exÃ©cution.

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----

-  La directive `entrypoint` est utilisÃ©e pour spÃ©cifier la commande qui sera exÃ©cutÃ©e lorsque le conteneur dÃ©marre.
- Dans ce cas, elle exÃ©cute une commande shell qui exÃ©cute un script nommÃ© `keygen.sh` situÃ© Ã  `/usr/local/bin/keygen.sh`.
- Le script reÃ§oit un argument `/ssh-dir`, qui est le rÃ©pertoire oÃ¹ le script effectuera ses opÃ©rations.

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
* La directive volumes est utilisÃ©e pour monter un volume nommÃ© `agent-ssh-dir` sur le chemin `/ssh-dir` Ã  l'intÃ©rieur du conteneur.
* Cela permet de conserver les donnÃ©es entre les redÃ©marrages du conteneur et peut Ã©galement Ãªtre utilisÃ© pour partager des donnÃ©es entre les conteneurs.

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
* Enfin, un healthcheck est dÃ©fini pour le service. Il s'agit d'une commande que Docker exÃ©cutera Ã  l'intÃ©rieur du conteneur pour vÃ©rifier sa santÃ©.
* Dans ce cas, la commande vÃ©rifie si un fichier nommÃ© `conductor_ok` existe dans le rÃ©pertoire `/ssh-dir`.
* Si le fichier existe, la commande rÃ©ussit et Docker considÃ¨re le service comme sain.
* Si le fichier n'existe pas, la commande Ã©choue et Docker considÃ¨re le service comme malsain.
* Docker exÃ©cutera cette vÃ©rification de santÃ© toutes les 5 secondes (`interval: 5s`), et si elle ne rÃ©pond pas dans les 10 secondes (`timeout: 10s`), Docker la considÃ©rera comme un Ã©chec. Docker rÃ©essaiera une vÃ©rification de santÃ© Ã©chouÃ©e 5 fois (`retries: 5`) avant de considÃ©rer le service comme malsain.

[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
* Service jenkins_controller
[%step]
** Ce service dÃ©pend du `sidekick_service`.
** Il ne dÃ©marrera que lorsque le `sidekick_service` aura terminÃ© avec succÃ¨s.
** C'est ce que signifie la condition `service_completed_successfully`.
--


[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Un `healthcheck` est Ã©galement dÃ©fini pour ce service.
[%step]
* Docker vÃ©rifie si un fichier nommÃ© `conductor_ok` existe dans le chemin `/ssh-dir`.
* Si le fichier existe, Docker considÃ¨re le service comme sain.
* Sinon, il est considÃ©rÃ© comme malsain.
--


[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Service `default_agent`
[%step]
* Ce service dÃ©pend Ã©galement du `sidekick_service` et du `jenkins_controller`.
* Il ne dÃ©marrera que lorsque le `sidekick_service` aura terminÃ© avec succÃ¨s et que le `jenkins_controller` aura dÃ©marrÃ©.
* C'est ce que signifient les conditions `service_completed_successfully` et `service_started`.
--

[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Un `healthcheck` est Ã©galement dÃ©fini pour ce service.
[%step]
* Docker vÃ©rifie si un fichier nommÃ© `authorized_keys` existe dans le chemin `/home/jenkins/.ssh`.
* Si le fichier existe, Docker considÃ¨re le service comme sain.
* Sinon, il est considÃ©rÃ© comme malsain.
--

[%auto-animate]
[.columns]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Enfin, un volume nommÃ© `agent-ssh-dir` est montÃ© sur le chemin `/home/jenkins/.ssh` Ã  l'intÃ©rieur du conteneur en lecture seule.
--

[%auto-animate]
== ğŸğŸ”¢ Ã‰tude de cas ğŸ“šğŸ”

Ã€ Ã©tudier au calme chez vous:

https://raw.githubusercontent.com/gounthar/MyFirstAndroidAppBuiltByJenkins/stf/jenkins/docker-compose.yml

image::47642838-image4.png[]

[.notes]
--
Dans le temps, on recommandait de faire un script qui attendait que le service soit dÃ©marrÃ© avant de continuer.
https://github.com/vishnubob/wait-for-it
--

== Transformer son application en docker compose

Deux approches diffÃ©rentes et complÃ©mentairesÂ :
[%step]
* https://www.composerize.com/
* https://github.com/jwilder/dockerize

== ğŸ“ Travaux pratiques #12

image::497269344-image5.png[]

https://gitlab.univ-artois.fr/bruno.verachten/devops-docker-tp12.git

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

Ã‡a vous dirait d'avoir votre propre forge Gitlab ?
[%step]
ğŸ˜ Non, et bien c'est parti quand mÃªme.
[%step]
* CrÃ©ez un nouveau fichier appelÃ© `docker-compose.yml`.
* Dans ce fichier, dÃ©finissez trois services : `gitlab`, `gitlab-runner-1` et `gitlab-runner-2`.
* Pour le service `gitlab`:
** utilisez l'image `gitlab/gitlab-ce:latest` (prÃ©fixÃ©e par le cache spÃ©cifique ILI)
** redÃ©marrez toujours le conteneur s'il s'arrÃªte,
** dÃ©finissez le nom d'hÃ´te sur `localhost`,
** dÃ©finissez l'URL externe sur `http://localhost` et exposez les ports `80`, `443` et `22`.

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS
[%step]
* Pour les services gitlab-runner-1 et gitlab-runner-2:
[%step]
** utilisez l'image `gitlab/gitlab-runner:latest` (prÃ©fixÃ©e par le cache spÃ©cifique ILI),
** redÃ©marrez toujours le conteneur s'il s'arrÃªte,
** dÃ©pendez du service gitlab et montez le socket Docker et le fichier de configuration de GitLab Runner.
[%step]
* CrÃ©ez des volumes pour:
[%step]
** les fichiers de configuration,
** les fichiers journaux
** et les fichiers de donnÃ©es de GitLab,
** ainsi que pour les fichiers de configuration de GitLab Runner.

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

Pas assez dÃ©taillÃ©? ğŸ˜¨
[%step]
* Ouvrez votre Ã©diteur de texte prÃ©fÃ©rÃ© et crÃ©ez un nouveau fichier.
* Nommez ce fichier `docker-compose.yml`.
* Commencez le fichier avec la ligne `services:` pour commencer Ã  dÃ©finir les services de votre application.
* Commencez Ã  dÃ©finir votre premier service en tapant `gitlab:` sur une nouvelle ligne. Ce sera le service pour votre serveur GitLab.
* Sous `gitlab:`, ajoutez les dÃ©tails de votre service.
[%step]
** Par exemple, `image: 'gitlab/gitlab-ce:latest'` pour spÃ©cifier l'image Docker Ã  utiliser pour ce service.

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

* Sous `gitlab:`, ajoutez les dÃ©tails de votre service.
** Par exemple, `image: 'gitlab/gitlab-ce:latest'` pour spÃ©cifier l'image Docker Ã  utiliser pour ce service.
** Continuez Ã  ajouter des dÃ©tails pour le service gitlab, comme `restart: always` pour toujours redÃ©marrer le conteneur s'il s'arrÃªte, et `hostname: 'localhost'` pour dÃ©finir le nom d'hÃ´te du serveur GitLab.
[%step]
* DÃ©finissez l'URL externe de votre serveur GitLab en ajoutant `environment:` et `GITLAB_OMNIBUS_CONFIG: |` sur de nouvelles lignes,
* puis `external_url 'http://localhost'` sur la ligne suivante.
* Exposez les ports nÃ©cessaires en ajoutant `ports:` sur une nouvelle ligne,
* puis `- '80:80'`, `- '443:443'` et `- '22:22'` sur les lignes suivantes.


[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

[%step]
* Montez les volumes nÃ©cessaires en ajoutant `volumes:` sur une nouvelle ligne,
[%step]
** puis `- 'gitlab_config:/etc/gitlab'`,
** `- 'gitlab_logs:/var/log/gitlab'`
** et `- 'gitlab_data:/var/opt/gitlab'` sur les lignes suivantes.
[%step]
* RÃ©pÃ©tez ces Ã©tapes pour les services gitlab-runner-1 et gitlab-runner-2, en remplaÃ§ant `gitlab` par `gitlab-runner-1` et `gitlab-runner-2` respectivement.


[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

[%step]
* Pour les services `gitlab-runner-1` et `gitlab-runner-2`, remplacez l'URL externe par une dÃ©pendance au service gitlab en ajoutant `depends_on:` sur une nouvelle ligne, puis `- gitlab` sur la ligne suivante.
* Montez le socket Docker et le fichier de configuration de GitLab Runner
[%step]
** en ajoutant `- '/var/run/docker.sock:/var/run/docker.sock'`
** et `- 'gitlab-runner-1-config:/etc/gitlab-runner'` (ou `- 'gitlab-runner-2-config:/etc/gitlab-runner'` pour `gitlab-runner-2`) sous `volumes:`.

[%auto-animate]
== ğŸ“ Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

[%step]
Enfin, dÃ©finissez les volumes pour votre application en ajoutant `volumes:` sur une nouvelle ligne Ã  la fin de votre fichier, puis
[%step]
** `- gitlab_config:`,
** `- gitlab_logs:`,
** `- gitlab_data:`,
** `- gitlab-runner-1-config:`
** et `- gitlab-runner-2-config:` sur les lignes suivantes.

== âœ… Solution Travaux pratiques #12-BIS ğŸ”¨ğŸ”¥

[source,yaml]
----
include::../code-samples/compose/tp12-bis.yml[]
----

[%auto-animate]
[.columns]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

[.column]
image::when.png[height=500px]
[.column]
video::gitlab-logs.speed.very.small.mp4[height=500px,options=autoplay,loop,nocontrols]

[%auto-animate]
[background-video="2000_years_later.mp4",background-video-loop=true,background-video-muted=true]
[.intellij.background]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

Il va falloir se logguer, lier les runners au serveur, crÃ©er un projet, etc...

[%auto-animate]
[.columns]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

[.column]
image::gitlab-login.png[height=500px]

[.column]
--
Pour trouver le mot de passe, il va falloir le demander gentiment Ã  Gitlab:

[source,bash]
----
docker compose -f tp12-bis.yml exec -it gitlab grep 'Password:' /etc/gitlab/initial_root_password
Password: qaPxXU+RqioolV3bAljvs2VYnyYa4jO/UYcis/UXLAk=
----
[%step]
Ensuite, il va falloir restreindre l'accÃ¨s:
[%step]
image::sign-up-restrictions.png[]
--

[%auto-animate]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

Pour utiliser le runner GitLab dans GitLab, vous devez le configurer.
[%step]
- Pour une configuration correcte, nous aurons besoin d'un jeton copiÃ© depuis le portail.
[%step]
- Pire que Ã§a, pas un jeton, mais carrÃ©ment une commande Ã  adapter Ã  `docker compose`.
[%step]
- Pour ce faire, allez Ã  l'adresse : http://localhost/admin/runners et cliquez sur le bouton "New instance runner".
[%step]
- Choisissez "Linux".
[%step]
- "Run untagged jobs"
[%step]
- Donnez une description au runner.
[%step]
- Cliquez sur le bouton "Create runner"
[%step]
- Vous avez ensuite une commande Ã  copier et modifier pour `docker compose`.


[%auto-animate]
[%notitle,background-iframe="https://www.youtube.com/embed/S-npLuur6KM?rel=0&start=0&enablejsapi=1&autoplay=1&loop=1&controls=1&modestbranding=1"]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

[.notes]
--
https://youtu.be/S-npLuur6KM
--

[%auto-animate]
== ğŸ”¨ğŸ”¥ J'ai ma forge! Bon, et maintenant? ğŸ˜

[source,bash]
----
docker compose -f tp12-bis.yml exec gitlab-runner-1 gitlab-runner register --url http://gitlab  --token glrt-PF5rLbUKzku5g8BL2y7J
Runtime platform                                    arch=amd64 os=linux pid=103 revision=853330f9 version=16.5.0
Running in system-mode.

Enter the GitLab instance URL (for example, https://gitlab.com/):
[http://gitlab]:
Verifying runner... is valid                        runner=PF5rLbUKz
Enter a name for the runner. This is stored only in the local config.toml file:
[3c2ee0d97d2b]: runner 1
Enter an executor: parallels, docker-autoscaler, docker+machine, custom, docker, docker-windows, shell, ssh, virtualbox, instance, kubernetes:
shell
Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded!

Configuration (with the authentication token) was saved in "/etc/gitlab-runner/config.toml"
----

[%auto-animate]
== !

image::gitlab-runners-compose.png[background, size=cover]

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™
On a vu dÃ©jÃ  l'instruction `depends_on` dans un fichier Docker Compose.
[%step]
- Elle permet de dÃ©finir des dÃ©pendances entre les services.
- Mais que faire si on veut dÃ©finir un lot de services qui fonctionnent ensemble, sans pour autant Ãªtre en interdÃ©pendanceâ€¯?
- Les profils dans Docker Compose permettent de dÃ©finir des groupes de services qui peuvent Ãªtre activÃ©s ou dÃ©sactivÃ©s ensemble.
- Cela peut Ãªtre utile pour gÃ©rer des environnements de dÃ©veloppement, de test et de production diffÃ©rents dans le mÃªme fichier Docker Compose.
- Pour dÃ©finir un profil pour un service, vous pouvez ajouter la clÃ© `profiles` Ã  la dÃ©finition du service dans votre fichier Docker Compose.

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™
Par exemple :

[%step]
[source,yaml]
----
services:
  mon_service:
    image: mon_image
    profiles:
      - dev
----
[%step]
Dans cet exemple, le service mon_service appartient au profil dev.

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™

[%step]
- Pour dÃ©marrer seulement les services qui appartiennent Ã  un certain profil, vous pouvez utiliser l'option `--profile` avec la commande `docker compose up`.
- Par exemple :

[%step]
[source,bash]
----
docker compose up --profile dev
----
[%step]
Cette commande dÃ©marrera seulement les services qui appartiennent au profil `dev`.

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™

[%step]
- Les profils peuvent rendre votre fichier Docker Compose plus organisÃ© et flexible.
- Ils vous permettent de dÃ©finir diffÃ©rents environnements dans le mÃªme fichier et de choisir facilement quels services dÃ©marrer en fonction de vos besoins.
- Jetons un coup d'Å“il Ã  un exemple de fichier Docker Compose avec des profils :

[%step]
[source,yaml]
----
services:
  service_dev:
    image: mon_image_dev
    profiles:
      - dev
  service_prod:
    image: mon_image_prod
    profiles:
      - prod
----
[%step]
- Dans cet exemple, nous avons deux services : `service_dev` et `service_prod`.
- Chacun appartient Ã  un profil diffÃ©rent.

[%auto-animate]
== ğŸ‘¤ Profils dans Docker Compose ğŸ™
[source,yaml]
----
services:
  service_dev:
    image: mon_image_dev
    profiles:
      - dev
  service_prod:
    image: mon_image_prod
    profiles:
      - prod
----
[%step]
- Nous pouvons choisir de dÃ©marrer seulement les services de dÃ©veloppement avec `docker compose up --profile dev`, ou uniquement les services de production avec `docker compose up --profile prod`.
- Les profils dans Docker Compose sont un outil puissant pour gÃ©rer diffÃ©rents environnements dans le mÃªme fichier Docker Compose.
- Ils peuvent rendre votre dÃ©veloppement et vos tests plus efficaces et organisÃ©s.

== ğŸ”¨ğŸ”¥ Une autre forge, Ã§a vous dit? ğŸ˜

[%step]
ğŸ˜ Non, et bien, c'est parti quand mÃªme.
[%step]
https://raw.githubusercontent.com/jenkins-docs/quickstart-tutorials/refs/heads/main/docker-compose.yaml
[%step]
[source,yaml]
----
include::../code-samples/compose/jenkins-docker-compose.yml[]
----

== ğŸ”¨ğŸ”¥ Une autre forge, Ã§a vous dit? ğŸ˜

Indigeste? ğŸ˜¨
[%step]
Ne relevons que les points importants:

[%step]
[source,yaml]
----
include::../code-samples/compose/jenkins-docker-compose.yml[lines=51..68]
----

[%auto-animate]
== ğŸ”¨ğŸ”¥ Une autre forge, Ã§a vous dit? ğŸ˜
Maven
[source,dockerfile]
----
include::../code-samples/compose/GSoC/maven/Dockerfile[]
----

[%auto-animate]
== ğŸ”¨ğŸ”¥ Une autre forge, Ã§a vous dit? ğŸ˜
Python
[source,yaml]
----
include::../code-samples/compose/jenkins-docker-compose.yml[lines=70..87]
----

[%auto-animate]
== ğŸ”¨ğŸ”¥ Une autre forge, Ã§a vous dit? ğŸ˜

[source,dockerfile]
----
include::../code-samples/compose/GSoC/python/Dockerfile[]
----

[%auto-animate]
== ğŸ”¨ğŸ”¥ Une autre forge, Ã§a vous dit? ğŸ˜
Ã€ vous maintenant!

[source,bash]
----
git clone https://github.com/jenkins-docs/quickstart-tutorials.git
----
[%step]
Ã€ vous de modifier les sources de faÃ§on Ã  passer par le cache ILI
[%step]
Ensuite, ne restera qu'Ã  lancer la "forge":
[%step]
[source,bash]
----
docker compose up --build -d --force-recreate maven
----
[%step]
Ou encore si vous voulez tout construire localement:
[%step]
[source,bash]
----
docker compose -f build-docker-compose.yaml up --build -d --force-recreate maven
----


[%auto-animate]
== !

image::jenkins-compose.png[background, size=cover]

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

Et pourquoi pas s'attaquer au docker compose qui a gÃ©nÃ©rÃ© ce coursâ€¯?

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

Et pourquoi pas s'attaquer au docker compose qui a gÃ©nÃ©rÃ© ce coursâ€¯?

[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[]
----

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

Et pourquoi pas s'attaquer au docker compose qui a gÃ©nÃ©rÃ© ce coursâ€¯?
[%step]
Indigeste? ğŸ˜¨
[%step]
Ne relevons que les points importants:

[%step]
Les ancres...
[%step]
[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=1..28]
----

[%auto-animate]
== â¡ï¸ğŸ”„ Les ancres dans `docker compose` âš“

Docker Compose permet de dÃ©finir et de gÃ©rer plusieurs services Docker dans un seul fichier YAML.
[%step]
- Les ancres (`&`) et les alias (`*`) sont des fonctionnalitÃ©s YAML qui peuvent Ãªtre utilisÃ©es dans Docker Compose pour rÃ©utiliser des configurations.
- Une ancre est une rÃ©fÃ©rence Ã  un objet ou Ã  une valeur dans un fichier YAML.
Elle est dÃ©finie en utilisant l'opÃ©rateur `&` suivi d'un nom unique.

[%step]
[source,yaml]
----
x-slides-base: &slides-base
  build:
    context: ./
----
[%step]
Dans cet exemple, `x-slides-base` est une ancre qui reprÃ©sente un objet avec une clÃ© `build`.

[%auto-animate]
== â¡ï¸ğŸ”„ Les ancres dans `docker compose` âš“

Les ancres peuvent Ãªtre rÃ©fÃ©rencÃ©es ailleurs dans le fichier YAML en utilisant l'opÃ©rateur `*`.
[%step]
[source,yaml]
----
services:
  serve:
    <<: *slides-base
----
[%step]
- Les ancres permettent de rÃ©utiliser des configurations, ce qui rend le fichier Docker Compose plus lisible et plus facile Ã  maintenir.
- Si vous devez modifier une configuration qui est utilisÃ©e Ã  plusieurs endroits, vous pouvez simplement modifier l'ancre.
- En conclusion, les ancres et les alias sont des outils puissants pour gÃ©rer des configurations complexes dans Docker Compose. Ils permettent de rÃ©duire la duplication et d'amÃ©liorer la lisibilitÃ© de votre fichier Docker Compose.

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

Le fameux qrcode...
[%step]
[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=52..59]
----

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

Le service qui construit les slides Ã  partir d'`asciidoc` avec `reveal.js`.
[%step]
[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=40..50]
----

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

Le service qui construit les slides Ã  partir d'`asciidoc` avec `reveal.js`.
[%step]
[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=32..38]
----

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

Le service qui construit le pdf Ã  partir des slides.
[%step]
[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=61..77]
----

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

Pour rappel, l'ancre contenaitÂ :
[%step]
[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=3..28]
----

[%auto-animate]
[.columns]
== â¡ï¸ğŸ”„ Build quoi? ğŸ› ï¸ğŸ“¦
[.column]
--
[%step]
- Docker BuildKit est un outil de construction de Docker qui apporte de nombreuses amÃ©liorations par rapport Ã  l'ancien systÃ¨me de construction.
- L'une de ces amÃ©liorations est la mise en cache en ligne.
- La mise en cache en ligne est une fonctionnalitÃ© de Docker BuildKit qui permet de rÃ©utiliser les couches de cache existantes lors de la construction d'une image Docker.

[%step]
image::multi-layered-cake-removebg-preview.png[height=100px]
--
[.column.is-one-third]
--
[%step]
Elle est activÃ©e en dÃ©finissant l'argument `BUILDKIT_INLINE_CACHE` Ã  `1`.

[%step]
[source,yaml]
----
args:
  BUILDKIT_INLINE_CACHE: 1
----
--

[%auto-animate]
[.columns]
== â¡ï¸ğŸ”„ Environnement ğŸŒğŸŒ¿
[.column]
--
[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=12..15]
----
--
[.column]
--
Deux variables d'environnement sont dÃ©finies pour le conteneur Docker : `PRESENTATION_URL` et `REPOSITORY_URL`.
[%step]
Ces variables sont dÃ©finies Ã  l'aide de la syntaxe `${VARIABLE_NAME}`, qui est une maniÃ¨re standard d'accÃ©der aux variables d'environnement dans les fichiers de configuration YAML.
--

[%auto-animate]
== â¡ï¸ğŸ”„ Environnement ğŸŒğŸŒ¿
[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=12..15]
----
Lorsque Docker Compose rencontre cette syntaxe, il cherche la valeur de la variable d'environnement dans plusieurs endroits, en suivant un ordre spÃ©cifique :
[%step]
* Il vÃ©rifie d'abord si la variable est dÃ©finie dans le shell courant.
* Si c'est le cas, il utilise cette valeur.
* Si la variable n'est pas dÃ©finie dans le shell, Docker Compose cherche ensuite dans un fichier `.env` situÃ© dans le mÃªme rÃ©pertoire que le fichier `docker-compose.yml`.
* Si la variable est dÃ©finie dans ce fichier, Docker Compose utilise cette valeur.

[%auto-animate]
== â¡ï¸ğŸ”„ Environnement ğŸŒğŸŒ¿
[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=12..15]
----
* Si la variable n'est dÃ©finie ni dans le shell ni dans le fichier `.env`, Docker Compose utilise la valeur par dÃ©faut spÃ©cifiÃ©e dans le fichier `docker-compose.yml` (s'il y en a une).
* Dans notre cas, aucune valeur par dÃ©faut n'est spÃ©cifiÃ©e, donc si la variable n'est dÃ©finie ni dans le shell ni dans le fichier `.env`, Docker Compose gÃ©nÃ©rera une erreur.

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

[source,yaml]
----
include::../code-samples/compose/cours/docker-compose.yml[lines=16..17]
----
[%step]
* Dans Docker, chaque instruction dans le Dockerfile est exÃ©cutÃ©e par un utilisateur particulier.
* Par dÃ©faut, cet utilisateur est root, mais pour des raisons de sÃ©curitÃ©, il est souvent recommandÃ© d'exÃ©cuter les processus en tant qu'utilisateur non root.
* Cette ligne dÃ©finit l'ID de l'utilisateur qui exÃ©cutera les commandes Ã  l'intÃ©rieur du conteneur Docker Ã  la valeur de la variable d'environnement `CURRENT_UID`.
* La syntaxe `${CURRENT_UID}` est utilisÃ©e pour accÃ©der Ã  la valeur d'une variable d'environnement.
* Dans ce cas, Docker Compose recherchera une variable d'environnement nommÃ©e `CURRENT_UID` et utilisera sa valeur.
* Si `CURRENT_UID` n'est pas dÃ©fini dans l'environnement oÃ¹ Docker Compose est exÃ©cutÃ©, Docker Compose renverra une erreur.

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

[source,yaml]
----
include::../code-samples/compose/cours/Dockerfile[]
----

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

[source,dockerfile]
----
include::../code-samples/compose/cours/Dockerfile[lines=16..23]
----
[%step]
* Ce Dockerfile met en place un environnement `Node.js` avec des outils et dÃ©pendances supplÃ©mentaires.
* Il installe les derniÃ¨res versions de `npm` et `npm-check-updates` globalement, copie les dÃ©pendances `npm` de l'application dans l'image Docker, et crÃ©e des liens symboliques pour `package.json` et `package-lock.json` Ã  la racine de `/app`.

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

[source,dockerfile]
----
include::../code-samples/compose/cours/Dockerfile[lines=29..34]
----
[%step]
* Il tÃ©lÃ©charge Ã©galement et installe une version spÃ©cifique de `FontAwesome`

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

[source,dockerfile]
----
include::../code-samples/compose/cours/Dockerfile[lines=36..42]
----
[%step]
* Il installe les dÃ©pendances `npm` en utilisant le `package-lock.json` (en revenant Ã  une installation `npm` rÃ©guliÃ¨re si nÃ©cessaire), et lie la commande `gulp` pour qu'elle soit disponible dans le `PATH`.

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

[source,dockerfile]
----
include::../code-samples/compose/cours/Dockerfile[lines=44..52]
----
[%step]
* Les tÃ¢ches `gulp` et la configuration sont copiÃ©es dans l'image Docker, un volume est dÃ©fini pour le rÃ©pertoire `/app`, et le port `8000` est exposÃ© pour `HTTP`.

[%auto-animate]
== Autre Ã©tude de cas ğŸ“šğŸ”

[source,dockerfile]
----
include::../code-samples/compose/cours/Dockerfile[lines=54..56]
----
[%step]
* Le point d'entrÃ©e est dÃ©fini sur `tini`, et `gulp` est exÃ©cutÃ© par dÃ©faut.

== ğŸ‹ Tini dans Docker

== ğŸ¤” Qu'est-ce que Tini ?

Tini est un `init` minuscule mais valide pour les conteneurs. Il est conÃ§u pour Ãªtre le systÃ¨me init le plus simple possible.

== ğŸ› ï¸ Que fait Tini ?

Tini fait deux choses :

. Il gÃ©nÃ¨re votre processus en tant que son enfant (directement, pas en tant que petit-enfant, comme le ferait un shell).
. Il attend ensuite les signaux et les transmet au processus enfant.

== ğŸ¯ Pourquoi Tini est-il utile dans Docker ?

. Docker exÃ©cute un seul processus dans un conteneur par dÃ©faut. Si ce processus gÃ©nÃ¨re des processus enfants et ne les rÃ©colte pas correctement, ils deviennent des processus zombies.
. Tini assure que ces processus zombies sont correctement rÃ©coltÃ©s, amÃ©liorant ainsi le comportement du conteneur et rÃ©duisant la probabilitÃ© de cas limites.

== ğŸ‹ Tini dans notre Dockerfile

Dans notre Dockerfile, nous utilisons Tini comme point d'entrÃ©e :

[source,dockerfile]
----
ENTRYPOINT ["/sbin/tini","-g","gulp"]
----

. Cela signifie que Tini est le premier processus qui est lancÃ© dans notre conteneur.
. Il lancera ensuite `gulp` en tant que processus enfant.
. Tout signal envoyÃ© au conteneur sera transmis par Tini Ã  `gulp`.
. Si `gulp` gÃ©nÃ¨re des processus enfants et ne les rÃ©colte pas, Tini le fera.

[%auto-animate]
== ğŸ‹ Docker peut travailler main dans la main avec d'autres outils... ğŸ‘«ğŸ¤

[source,makefile]
----
include::../code-samples/compose/cours/Makefile[]
----

[%auto-animate]
== ğŸ‹ Docker peut travailler main dans la main avec d'autres outils... ğŸ‘«ğŸ¤

[source,makefile]
----
include::../code-samples/compose/cours/Makefile[lines=8..11]
----

Cette configuration de docker compose concerne Docker BuildKit, une fonctionnalitÃ© de Docker qui amÃ©liore les performances de construction des images Docker.

* La ligne `DOCKER_BUILDKIT ?= 1` vÃ©rifie si la variable d'environnement `DOCKER_BUILDKIT` est dÃ©jÃ  dÃ©finie.
** Si ce n'est pas le cas, elle lui attribue la valeur `1`, ce qui active Docker BuildKit.
* De mÃªme, `COMPOSE_DOCKER_CLI_BUILD ?= 1` vÃ©rifie si la variable d'environnement `COMPOSE_DOCKER_CLI_BUILD` est dÃ©jÃ  dÃ©finie.
** Si ce n'est pas le cas, elle lui attribue la valeur `1`.
** Cette variable d'environnement est utilisÃ©e pour activer l'utilisation de Docker CLI lors de l'utilisation de Docker Compose.
** C'est nÃ©cessaire car Docker Compose ne supporte pas BuildKit par dÃ©faut, donc cette variable d'environnement est une solution de contournement pour l'activer.
[%step]
En rÃ©sumÃ©, ces deux lignes de code activent Docker BuildKit pour amÃ©liorer les performances de construction des images Docker lors de l'utilisation de Docker Compose.

[%auto-animate]
== ğŸ‹ Docker peut travailler main dans la main avec d'autres outils... ğŸ‘«ğŸ¤

[source,makefile]
----
include::../code-samples/compose/cours/Makefile[lines=13..30]
----

[%auto-animate]
== ğŸ‹ Docker peut travailler main dans la main avec d'autres outils... ğŸ‘«ğŸ¤

[source,makefile]
----
include::../code-samples/compose/cours/Makefile[lines=35..41]
----
[%step]
* Cette rÃ¨gle `Makefile` est utilisÃ©e pour construire le projet Ã  l'intÃ©rieur d'un conteneur Docker.
* Elle utilise la fonction `compose_up` pour exÃ©cuter la commande `docker compose up` avec l'option `--exit-code-from=build`.
* Cette option permet Ã  la commande `docker compose up` de renvoyer le code de sortie du service `build`, ce qui permet Ã  Make de savoir si la construction du projet a rÃ©ussi ou non.

== ğŸ“–ğŸ”š Fin du chapitre docker compose ğŸ‹ğŸ™

image::bitmoji-whale friend.png[height=500px]
