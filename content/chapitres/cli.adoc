[{invert}]
= Ligne de commande

Guide de survie

== ğŸ¤” ProblÃ©matique

* Communication Humain <-> Machine

* Base commune de TOUS les outils

[{invert}]
== CLI

- ğŸ‡¬ğŸ‡§ CLI == "Command Line Interface"
- ğŸ‡«ğŸ‡· "Interface de Ligne de Commande"

== REPL

Pour les thÃ©oriciens et curieux :

- ğŸ‡¬ğŸ‡§ REPL == "Readâ€“evalâ€“print loop"

https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop[]

== Anatomie d'une commande

[source,bash]
----
ls --color=always -l /bin
----

* SÃ©parateur : l'espace
* Premier Ã©lÃ©ment (`ls`) : c'est la commande
* Les Ã©lÃ©ments commenÃ§ant par un tiret `-` sont des "options" et/ou drapeaux ("flags")
** "Option" == "Optionnel"
* Les autres Ã©lÃ©ments sont des arguments  (`/bin`)
** NÃ©cessaire (par opposition)

== Manuel des commande

* Afficher le manuel de `<commande>` :
+
[source,bash]
----
# Commande 'man' avec comme argument le nom de ladite commande
man <commande>
----

** Navigation avec les flÃ¨ches haut et bas
*** Tapez `/` puis une chaÃ®ne de texte pour chercher
*** Touche `n` pour sauter dâ€™occurrence en occurrence
** Touche `q` pour quitter

ğŸ“ Essayez avec `ls`, chercher le mot `color`

[.small]
- ğŸ’¡ La majoritÃ© des commandes fournit Ã©galement une option (`--help`), un flag (`-h`)  ou un argument (`help`)
- Google c'est pratique aussi hein !

== Raccourcis

Dans un terminal Unix/Linux/WSL :

* `CTRL + C` : Annuler le process ou prompt en cours
* `CTRL + L` : Nettoyer le terminal
* `CTRL + A` : Positionner le curseur au dÃ©but de la ligne
* `CTRL + E` : Positionner le curseur Ã  la fin de la ligne
* `CTRL + R` : Rechercher dans l'historique de commandes

[.small]
ğŸ“ Essayez-les !

== Commandes de base 1/2

* `pwd` : Afficher le rÃ©pertoire courant
** ğŸ“ Option `-P` ?
* `ls` : Lister le contenu du rÃ©pertoire courant
** ğŸ“ Options `-a` et `-l` ?
* `cd` : Changer de rÃ©pertoire
** ğŸ“ Sans argument : que se passe t'il ?
* `cat` : Afficher le contenu d'un fichier
** ğŸ“ Essayez avec plusieurs arguments
* `mkdir` : crÃ©er un rÃ©pertoire
** ğŸ“ Option `-p` ?

== Commandes de base 2/2

* `echo` : Afficher un (des) message(s)
* `rm` : Supprimer un fichier ou dossier
* `touch` : CrÃ©er un fichier
* `grep` : Chercher un motif de texte

== Arborescence de fichiers 1/2

* Le systÃ¨me de fichier a une structure d'arbre
** La racine du disque dur c'est `/` : ğŸ“ `ls -l /`
** Le sÃ©parateur c'est Ã©galement `/` : ğŸ“ `ls -l /usr/bin`

* Deux types de chemins :
** Absolu (depuis la racine): Commence par `/` (Ex. `/usr/bin`)
** Sinon c'est relatif (e.g. depuis le dossier courant) (Ex `./bin` ou `local/bin/`)

image::linux-directory-structure.png[width=400]

[.small]
link:https://linuxhandbook.com/linux-directory-structure/[Source,window="_blank"]

== Arborescence de fichiers 2/2

* Le dossier "courant" c'est `.` : ğŸ“ `ls -l ./bin # Dans le dossier /usr`
* Le dossier "parent" c'est `..` : ğŸ“ `ls -l ../ # Dans le dossier /usr`


* `~` (tilde) c'est un raccourci vers le dossier de l'utilisateur courant : ğŸ“ `ls -l ~`
* Sensible Ã  la casse (majuscules/minuscules) et aux espaces :
ğŸ“
+
[source,bash]
----
ls -l /bin
ls -l /Bin
mkdir ~/"Accent tuÃ©"
ls -d ~/Accent\ tuÃ©
----

== Un language (?)

* Variables interpolÃ©es avec le caractÃ¨re "dollar" `$` :
+
[source,bash]
----
echo $MA_VARIABLE
echo "$MA_VARIABLE"
echo ${MA_VARIABLE}

# Recommendation
echo "${MA_VARIABLE}"

MA_VARIABLE="Salut tout le monde"

echo "${MA_VARIABLE}"
----

* Sous commandes avec `$(<command>)`:

[source,bash]
----
echo ">> Contenu de /tmp :\n$(ls /tmp)"
----

* Des `if`, des `for` et plein d'autres trucs (link:https://tldp.org/LDP/abs/html/[window="_blank"])

== Codes de sortie

* Chaque exÃ©cution de commande renvoie un code de retour (ğŸ‡¬ğŸ‡§ "exit code")
** Nombre entier entre 0 et 255 (en link:https://en.wikipedia.org/wiki/POSIX[POSIX,window="_blank"])

* Code accessible dans la variable *Ã©phÃ©mÃ¨re* `$?` :

[source,bash]
----
ls /tmp
echo $?

ls /do_not_exist
echo $?

# Une seconde fois. Que se passe-t'il ?
echo $?
----

== EntrÃ©e, sortie standard et d'erreur

image:cli-ios.png[]

[source,bash]
----
ls -l /tmp
echo "Hello" > /tmp/hello.txt
ls -l /tmp
ls -l /tmp >/dev/null
ls -l /tmp 1>/dev/null

ls -l /do_not_exist
ls -l /do_not_exist 1>/dev/null
ls -l /do_not_exist 2>/dev/null

ls -l /tmp /do_not_exist
ls -l /tmp /do_not_exist 1>/dev/null 2>&1
----

== Pipelines

* Le caractÃ¨re "pipe" `|` permet de chaÃ®ner des commandes
** Le "stdout" de la premiÃ¨re commande est branchÃ©e sur le "stdin" de la seconde

* Exemple : Afficher les fichiers/dossiers contenant le lettre `d` dans le dossier `/bin` :

[source,bash]
----
ls -l /bin

ls -l /bin | grep "d" --color=auto
----

== ExÃ©cution 1/2

* Les commandes sont des fichier binaires exÃ©cutables sur le systÃ¨me :
+
[source,bash]
----
command -v cat # Ã©quivalent de "which cat"

ls -l "$(command -v cat)"
----

* La variable d'environnement `$PATH` liste les dossiers dans lesquels chercher les binaires
** ğŸ’¡ Utiliser cette variable quand une commande fraÃ®chement installÃ©e n'est pas trouvÃ©e

== ExÃ©cution 2/2

* ExÃ©cution de scripts :
** Soit appel direct avec l'interprÃ©tateur : `sh ~/monscript.txt`
** Soit droit d'exÃ©cution avec un "shebang" (e.g. `#!/bin/bash`)
+
[source,bash]
----
$ chmod +x ./monscript.sh

$ head -n1 ./monscript.sh
#!/bin/bash

$ ./monscript.sh
# ExÃ©cution
----
