= R√©seaux et Docker

[.title]
Interagir avec le Docker ENGINE

image::2375.png[]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output2_with_transparency.png[height=600]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output3_with_transparency.png[height=600]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output4_with_transparency.png[height=600]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output5_with_transparency.png[height=600]

[.notes]
--
La communication d'un navigateur avec le moteur Docker sur le port 2375 peut se faire via l'API Docker expos√©e sur ce port. Voici comment cela fonctionne :

Exposer l'API Docker sur le port 2375 : Tout d'abord, pour permettre la communication du navigateur avec le moteur Docker, vous devez vous assurer que l'API Docker est expos√©e sur le port 2375. Vous pouvez sp√©cifier cela lors de la configuration du moteur Docker. Par exemple, en utilisant l'option -H :

[source,bash]
----
dockerd -H tcp://0.0.0.0:2375
----
Cela signifie que le moteur Docker √©coutera les requ√™tes sur le port 2375.

Utilisation de l'API Docker : Une fois que l'API Docker est expos√©e, vous pouvez effectuer des op√©rations Docker en utilisant des requ√™tes HTTP. Le navigateur peut envoyer des requ√™tes HTTP directement √† l'adresse IP du serveur Docker et au port 2375.

Par exemple, pour lister les conteneurs en cours d'ex√©cution, vous pouvez utiliser une requ√™te HTTP GET :

[source,http]
----
GET http://adresse_ip_du_serveur_docker:2375/containers/json
----
Le serveur Docker r√©pondra avec les d√©tails des conteneurs en cours d'ex√©cution au format JSON.

S√©curit√© : Il est important de noter que l'exposition de l'API Docker sur un port non s√©curis√© peut pr√©senter des risques de s√©curit√©, car n'importe qui avec acc√®s au port 2375 peut potentiellement contr√¥ler le moteur Docker. Pour des raisons de s√©curit√©, il est recommand√© de limiter l'acc√®s √† l'API Docker en utilisant des m√©canismes d'authentification, d'autorisation et de chiffrement.

Outils tiers : En pratique, les navigateurs ne sont pas souvent utilis√©s pour interagir directement avec l'API Docker. Au lieu de cela, des outils tiers, des biblioth√®ques ou des clients Docker sont souvent utilis√©s pour simplifier les op√©rations Docker et fournir une couche de s√©curit√© suppl√©mentaire.
--

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

image::reseaux-output6_with_transparency.png[height=600]

[.notes]
--
[source,bash]
----
for i in {2..6}; do convert Diapositive${i}.PNG -crop 9004x5341+1968+1654 -transparent white -resize x1080 reseaux-output${i}_with_transparency.png; done
----

--

[.intellij.background]
== Ex : int√©gration IntelliJ

image::intellij-docker.png[background, size=cover, position=left, opacity=0.1]

[%auto-animate]
== ü§ù Interagir avec le Docker Engine

Sauf que...

image::reseaux-docker-desktop-2375-configuration.png[width=600]

== Les r√©seaux de containers

image::1435904594-image8.png[]

[%auto-animate]
== üó∫Ô∏èüîÄ Mapping de Port : Rappel

[source,bash]
----
docker container run ‚Äìd -p 8000:80 nginx
----

[%auto-animate]
== üó∫Ô∏èüîÄ Mapping de Port : Rappel

image::reseaux-output11_with_transparency.png[]

[%auto-animate]
== üó∫Ô∏èüîÄ Mapping de Port : Rappel

image::reseaux-output12_with_transparency.png[]

[%step]
[source,bash]
----
curl -I --noproxy '*' http://172.17.0.2:80
It works!
----

[%step]
[source,bash]
----
curl -I --noproxy '*' http://localhost:8000
It works too!
----

[.notes]
--
[source,bash]
----
for i in {11..12}; do convert Diapositive${i}.PNG -crop 8833x2599+2250+1833 -transparent white -resize x1080 reseaux-output${i}_with_transparency.png; done
----
--

[%auto-animate]
== üåê Les r√©seaux

[source,bash]
----
docker network ls
----

[%step]
[source,bash]
----
NETWORK ID     NAME                                                             DRIVER    SCOPE
11b7af7b16e4   bridge                                                           bridge    local
1112832d205b   cours-devops-docker_default                                      bridge    local
7ab15cc28199   docker_volumes-backup-extension-desktop-extension_default        bridge    local
34caf4674478   host                                                             host      local
2a179c7be3b3   none                                                             null      local
0c577a792771   portainer_portainer-docker-extension-desktop-extension_default   bridge    local
----

[%step]
image::les_r√©seaux.png[]

[.notes]
--
Dans le contexte de la commande "docker network ls", la colonne "DRIVER" (pilote) fait r√©f√©rence au pilote r√©seau utilis√© pour cr√©er le r√©seau Docker. Voici quelques explications concernant les valeurs possibles de cette colonne :

1. **Local (bridge)** : Un r√©seau avec une port√©e "local" est g√©n√©ralement un r√©seau de pont (bridge).
Il n'est accessible qu'√† l'int√©rieur de l'h√¥te Docker o√π il a √©t√© cr√©√©.
Les conteneurs connect√©s au m√™me r√©seau local peuvent communiquer entre eux, mais ce r√©seau est isol√© des autres h√¥tes Docker ou r√©seaux externes.
2. **Host (h√¥te)** : Un r√©seau avec une port√©e "host" n'offre aucune isolation r√©seau, ce qui signifie qu'il est accessible depuis l'h√¥te o√π Docker est en cours d'ex√©cution.
Les conteneurs sur ce r√©seau partagent la pile r√©seau de l'h√¥te et peuvent acc√©der directement aux ressources de l'h√¥te.
3. **Null (null)** : Un r√©seau avec une port√©e "null" est un type de r√©seau qui ne fournit aucune connectivit√©.
C'est essentiellement un r√©seau sans port√©e, et il est utilis√© pour les conteneurs qui n'ont pas besoin d'un acc√®s r√©seau.

D'autres pilotes de r√©seau peuvent √©galement √™tre disponibles, en fonction de la configuration de Docker et des plugins install√©s.
Chaque pilote offre des fonctionnalit√©s et des options de configuration sp√©cifiques pour r√©pondre aux besoins de divers cas d'utilisation.

La colonne "DRIVER" vous permet de comprendre quel pilote r√©seau est associ√© √† chaque r√©seau Docker et comment il fonctionne.
Elle joue un r√¥le essentiel dans la d√©finition de la mani√®re dont les conteneurs communiquent entre eux et avec le r√©seau externe.
--


[%auto-animate]
== üåê Les r√©seaux

[source,bash]
----
docker network ls
----

[source,bash]
----
NETWORK ID     NAME                                                             DRIVER    SCOPE
11b7af7b16e4   bridge                                                           bridge    local
1112832d205b   cours-devops-docker_default                                      bridge    local
7ab15cc28199   docker_volumes-backup-extension-desktop-extension_default        bridge    local
34caf4674478   host                                                             host      local
2a179c7be3b3   none                                                             null      local
0c577a792771   portainer_portainer-docker-extension-desktop-extension_default   bridge    local
----

image::les_r√©seaux.png[]

[.notes]
--
Le terme "SCOPE" dans le contexte de "docker network ls" se r√©f√®re au domaine de validit√© du r√©seau Docker. Voici une explication en fran√ßais :

1. **Local** : Lorsque vous voyez "local" dans la colonne "SCOPE", cela signifie que le r√©seau Docker a une port√©e locale.
Les r√©seaux ayant une port√©e locale sont accessibles uniquement sur l'h√¥te o√π ils ont √©t√© cr√©√©s.
Les conteneurs sur cet h√¥te peuvent se connecter au r√©seau, mais ils ne peuvent pas le faire depuis d'autres h√¥tes.
2. **Global** : En revanche, si vous voyez "global" dans la colonne "SCOPE", cela signifie que le r√©seau Docker a une port√©e globale.
Cela permet aux conteneurs de se connecter √† ce r√©seau depuis d'autres h√¥tes de votre environnement Docker.

Ainsi, la valeur "SCOPE" vous indique si un r√©seau Docker est limit√© √† un seul h√¥te (port√©e locale) ou s'il est accessible depuis d'autres h√¥tes (port√©e globale).
La port√©e d√©termine la mani√®re dont les conteneurs peuvent communiquer avec ce r√©seau, en fonction de la configuration de Docker.
--

== üîçüåê Les r√©seaux : inspection

[source,bash]
----
docker network inspect bridge
----

[%step]
[source,bash]
----
[
    {
        "Name": "bridge",
        "Id": "11b7af7b16e4cf9fe42733aa1b6900ed876407e3b55e692c9dfe03505e2af19f",
        "Created": "2023-10-31T15:08:44.054140179Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        ...
----

[.notes]
--
Lorsque vous ex√©cutez la commande "docker network inspect bridge," vous obtenez des informations sur le r√©seau "bridge" dans Docker.

Voici ce que chaque √©l√©ment signifie :

1. **Name (Nom)** : C'est le nom du r√©seau, dans ce cas, "bridge." Docker attribue un nom par d√©faut √† ce r√©seau, qui est utilis√© par les conteneurs pour communiquer entre eux.
2. **Id (Identifiant)** : C'est un identifiant unique attribu√© au r√©seau Docker, utilis√© en interne par Docker pour le g√©rer. Il est g√©n√©r√© automatiquement.
3. **Created (Cr√©√©)** : Cette date indique quand le r√©seau a √©t√© cr√©√©. Cela peut √™tre utile pour suivre l'historique des op√©rations Docker.
4. **Scope (Port√©e)** : Dans cet exemple, la port√©e est "local," ce qui signifie que le r√©seau "bridge" est uniquement accessible localement sur l'h√¥te Docker. Les conteneurs sur cet h√¥te peuvent se connecter au r√©seau "bridge," mais les conteneurs sur d'autres h√¥tes Docker ne le peuvent pas.
5. **Driver (Pilote)** : Le pilote du r√©seau "bridge" est "bridge." C'est le pilote par d√©faut utilis√© pour connecter les conteneurs sur un m√™me h√¥te.
6. **EnableIPv6 (Activer IPv6)** : Dans cet exemple, la valeur est "false," ce qui signifie que l'IPv6 n'est pas activ√© sur ce r√©seau. Docker prend en charge √† la fois l'IPv4 et l'IPv6.
7. **IPAM (IP Address Management - Gestion des adresses IP)** : C'est la section qui g√®re les adresses IP pour le r√©seau. Dans cet exemple, le pilote est "default," ce qui signifie que Docker utilise ses param√®tres par d√©faut pour g√©rer les adresses IP.
8. **Subnet (Sous-r√©seau)** : C'est l'intervalle d'adresses IP utilis√© par les conteneurs connect√©s √† ce r√©seau. Dans cet exemple, le sous-r√©seau est "172.17.0.0/16," ce qui signifie que les adresses IP de ce r√©seau sont comprises entre 172.17.0.1 et 172.17.255.254.
9. **Gateway (Passerelle)** : Il s'agit de l'adresse IP de la passerelle utilis√©e par les conteneurs pour acc√©der √† d'autres r√©seaux ou √† Internet. Dans ce cas, la passerelle est "172.17.0.1."

Ces informations fournissent un aper√ßu de la configuration du r√©seau "bridge" dans Docker.
--

== üåê‚ú® Les r√©seaux : cr√©ation

[source,bash]
----
docker network create mon-reseau
----

[%step]
[source,bash]
----
docker network ls
----

[%step]
[source,bash]
----
NETWORK ID     NAME                                                             DRIVER    SCOPE
11b7af7b16e4   bridge                                                           bridge    local
1112832d205b   cours-devops-docker_default                                      bridge    local
7ab15cc28199   docker_volumes-backup-extension-desktop-extension_default        bridge    local
34caf4674478   host                                                             host      local
46953dc9b3d5   mon-reseau                                                       bridge    local
2a179c7be3b3   none                                                             null      local
0c577a792771   portainer_portainer-docker-extension-desktop-extension_default   bridge    local
----

[.notes]
--
Lorsque vous ex√©cutez la commande "docker network create mon-reseau," vous cr√©ez un nouveau r√©seau Docker avec le nom "mon-reseau." Voici ce que chaque √©l√©ment signifie :

1. **NETWORK ID (Identifiant du r√©seau)** : C'est un identifiant unique attribu√© au r√©seau que Docker utilise en interne pour le g√©rer. Il est g√©n√©r√© automatiquement.
2. **NAME (Nom)** : Il s'agit du nom que vous avez choisi pour votre r√©seau, dans ce cas, "mon-reseau."
3. **DRIVER (Pilote)** : Le pilote de ce r√©seau est "bridge." Le pilote "bridge" est utilis√© pour connecter des conteneurs sur le m√™me h√¥te.
4. **SCOPE (Port√©e)** : Dans cet exemple, la port√©e est "local," ce qui signifie que le r√©seau "mon-reseau" est uniquement accessible localement sur l'h√¥te Docker. Les conteneurs sur cet h√¥te peuvent se connecter √† "mon-reseau," mais les conteneurs sur d'autres h√¥tes Docker ne le peuvent pas.

Ensuite, lorsque vous ex√©cutez "docker network ls," vous obtenez une liste de tous les r√©seaux Docker existants, y compris celui que vous venez de cr√©er ("mon-reseau").
Vous pouvez voir les d√©tails de ce r√©seau dans le tableau, y compris son identifiant, son nom, son pilote, et sa port√©e.

En r√©sum√©, avec ces commandes, vous avez cr√©√© un nouveau r√©seau Docker nomm√© "mon-reseau" qui peut √™tre utilis√© pour connecter des conteneurs sur le m√™me h√¥te.
--

== üê≥üîó Attacher un container √† un r√©seau particulier

[source,bash]
----
docker run ‚Äìd --net=mon-reseau --name=app img
----

[%step]
Il est opportun de nommer un container quand on l'attache √† un r√©seau.

[%step]
Docker fournit un DNS interne dans les r√©seaux custom. Les containers d'un m√™me r√©seau peuvent se "voir" et "s'appeler" par leur noms.

[%auto-animate]
== üñ•Ô∏èüîç MicroDNS

[source,bash]
----
docker network create mynet
----

[%step]
[source,bash]
----
docker container run -d --name web --net mynet nginx
----

[%step]
[source,bash]
----
docker container run --net mynet alpine ping web
----

[%step]
[source,bash]
----
PING web (172.21.0.2): 56 data bytes
64 bytes from 172.21.0.2: seq=0 ttl=64 time=0.442 ms
64 bytes from 172.21.0.2: seq=1 ttl=64 time=0.105 ms
64 bytes from 172.21.0.2: seq=2 ttl=64 time=0.099 ms
64 bytes from 172.21.0.2: seq=3 ttl=64 time=0.150 ms
64 bytes from 172.21.0.2: seq=4 ttl=64 time=0.114 ms
64 bytes from 172.21.0.2: seq=5 ttl=64 time=0.098 ms
64 bytes from 172.21.0.2: seq=6 ttl=64 time=0.099 ms
64 bytes from 172.21.0.2: seq=7 ttl=64 time=0.100 ms
64 bytes from 172.21.0.2: seq=8 ttl=64 time=0.114 ms
64 bytes from 172.21.0.2: seq=9 ttl=64 time=0.097 ms
^C
--- web ping statistics ---
10 packets transmitted, 10 packets received, 0% packet loss
round-trip min/avg/max = 0.097/0.141/0.442 ms
----

[%auto-animate]
== üñ•Ô∏èüîç MicroDNS

image::appeler_son_voisin.png[height=600]

== üì∂üîå Se connecter √† un r√©seau

[source,bash]
----
docker network connect mynet myapp
----

[%step]
Cette commande permet d'attacher un container √† un r√©seau apr√®s sa cr√©ation.


== üéì Travaux pratiques #11

√âtapes:

[%step]
* Lister et inspecter les r√©seaux existants
* Lancer un container `nginx `nomm√© "web1"
* A quel r√©seau est-il attach√© ?
* Cr√©er un r√©seau de type bridge et l'inspecter
* Lancer un container `nginx` nomm√© "web2" et l'attacher au r√©seau cr√©√©
* L'inspection confirme-t-elle l'attachement ?
* Lancer un bash dans le container "web1"
* Est-ce que "web1" peut voir "web2" ?
* Corriger pour que ce soit le cas

[%auto-animate]
== ‚úÖ Solution travaux pratiques #11

√âtape 1 : Lister et inspecter les r√©seaux existants

[source,bash]
----
# Liste tous les r√©seaux Docker existants
docker network ls

# Inspecte un r√©seau sp√©cifique (par exemple, le r√©seau bridge, d'autres r√©seaux peuvent √™tre inspect√©s)
docker network inspect bridge
----

[%step]
√âtape 2 : Lancer un container "nginx" nomm√© "web1"
[%step]
[source,bash]
----
# Lance un conteneur "nginx" nomm√© "web1"
docker container run --name web1 -d nginx
----

[%step]
√âtape 3 : V√©rifier le r√©seau auquel "web1" est attach√©
[%step]
[source,bash]
----
# R√©cup√®re l'identifiant de r√©seau complet pour le container "web1"
network_id=$(docker container inspect -f '{{.NetworkSettings.Networks.bridge.NetworkID}}' web1)

# Raccourcit l'identifiant du r√©seau aux premiers 12 caract√®res
shortened_network_id=$(echo $network_id | cut -c 1-12)

# Liste tous les r√©seaux docker, en filtrant par l'identifiant du r√©seau
docker network ls --format "table {{.ID}}\t{{.Name}}" | awk -v network_id="$shortened_network_id" '$1 == network_id {print $2}'
----

[%auto-animate]
== ‚úÖ Solution travaux pratiques #11

√âtape 3 : V√©rifier le r√©seau auquel "web1" est attach√©
[source,bash]
----
# R√©cup√®re l'identifiant de r√©seau complet pour le container "web1"
network_id=$(docker container inspect -f '{{.NetworkSettings.Networks.bridge.NetworkID}}' web1)

# Raccourcit l'identifiant du r√©seau aux premiers 12 caract√®res
shortened_network_id=$(echo $network_id | cut -c 1-12)

# Liste tous les r√©seaux docker, en filtrant par l'identifiant du r√©seau
docker network ls --format "table {{.ID}}\t{{.Name}}" | awk -v network_id="$shortened_network_id" '$1 == network_id {print $2}'
----
[source,bash]
----
bridge
----

[%step]
√âtape 4 : Cr√©er un r√©seau de type bridge et l'inspecter
[%step]
[source,bash]
----
# Cr√©e un r√©seau Docker de type bridge nomm√© "mon-reseau"
docker network create mon-reseau

# Inspecte le r√©seau "mon-reseau"
docker network inspect mon-reseau
----

[%step]
√âtape 5 : Lancer un container "nginx" nomm√© "web2" et l'attacher au r√©seau cr√©√©
[%step]
[source,bash]
----
# Lance un conteneur "nginx" nomm√© "web2" et l'attache au r√©seau "mon-reseau"
docker container run --name web2 -d --network mon-reseau nginx
----

[%auto-animate]
== ‚úÖ Solution travaux pratiques #11

√âtape 5 : Lancer un container "nginx" nomm√© "web2" et l'attacher au r√©seau cr√©√©
[source,bash]
----
# Lance un conteneur "nginx" nomm√© "web2" et l'attache au r√©seau "mon-reseau"
docker container run --name web2 -d --network mon-reseau nginx
----

√âtape 6 : V√©rifier l'attachement du container "web2" au r√©seau
[%step]
[source,bash]
----
# Inspecte le conteneur "web2" pour v√©rifier le r√©seau auquel il est attach√©
docker container inspect web2 | grep NetworkMode
----

[%step]
√âtape 7 : Lancer un bash dans le container "web1"
[%step]
[source,bash]
----
# Lance un shell interactif dans le conteneur "web1"
docker container exec -it web1 bash
----

[%step]
√âtape 8 : V√©rifier si "web1" peut voir "web2"
[%step]
[source,bash]
----
# √Ä l'int√©rieur du conteneur "web1," essayez de faire une requ√™te HTTP vers "web2"
curl web2
----
[%step]
[source,bash]
----
curl: (6) Could not resolve host: web2
----

[%auto-animate]
== ‚úÖ Solution travaux pratiques #11

√âtape 9 : Corriger pour permettre la communication entre "web1" et "web2"
[%step]
[source,bash]
----
# Sortez du shell du conteneur "web1" en tapant "exit"

# Attachez "web1" au m√™me r√©seau "mon-reseau"
docker network connect mon-reseau web1
----
[%step]
Apr√®s avoir suivi ces √©tapes, les conteneurs "web1" et "web2" devraient √™tre attach√©s au m√™me r√©seau "mon-reseau" et √™tre capables de communiquer entre eux.

[%step]
[source,bash]
----
# Lance un shell interactif dans le conteneur "web1"
docker container exec -it web1 bash
----

[%step]
[source,bash]
----
# √Ä l'int√©rieur du conteneur "web1," essayez de faire une requ√™te HTTP vers "web2"
curl web2
----

[%step]
[source,html]
----
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
[...]
----