[{invert}]
= Docker Images

image::multi-layered-cake.jpeg[width=900]

== 🤔 Pourquoi des images ?

* Un *conteneur* est toujours exécuté depuis une *image*.
* Une *image de conteneur* (ou "Image Docker") est un  modèle ("template") d'application auto-suffisant.

=> Permet de fournir un livrable portable (ou presque).

[%auto-animate]
== 🤔 C'est quoi une image ?

image::multi-layered-cake-removebg-preview.png[background, size=contain, position=left, opacity=0.1]

C'est une collection de fichiers et de metadonnées.

== 🤔 C'est quoi une image ?

image::multi-layered-cake-removebg-preview.png[background, size=contain, position=left, opacity=0.1]

C'est une collection de fichiers et de metadonnées.

C'est une suite de couches superposées.

== 🤔 C'est quoi une image ?

C'est une collection de fichiers et de metadonnées.

C'est une suite de couches superposées.

image::images-output5_with_transparency.png[]

[%auto-animate]
== 🤔 C'est quoi une image ?

C'est une collection de fichiers et de metadonnées.

C'est une suite de couches superposées.

image::images-output6_with_transparency.png[]

[%auto-animate]
== 🍰 Détail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output8_with_transparency.png[]

[%auto-animate]
== 🍰 Détail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output9_with_transparency.png[]

[%auto-animate]
== 🍰 Détail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output10_with_transparency.png[]

[%auto-animate]
== 🍰 Détail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output11_with_transparency.png[]

[%auto-animate]
== 🍰 Détail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output12_with_transparency.png[]

[%auto-animate]
== 🍰 Détail des couches

Exemple d'une image Apache HTTPd "custom"

image::images-output13_with_transparency.png[]

[.notes]
--
[source,bash]
----
for i in {8..13}; do convert Diapositive${i}.PNG -crop 10221x4830+1556+2420 -transparent white -resize x1080 images-output${i}_with_transparency.png; done
----
--

== Dicton du jour

**__"L'image est à la classe ce que le container est à l'objet"__**

image::dicton-du-jour.png[]

== !

🤔 Application Auto-Suffisante ?

image::docker-app-self-sufficient.png[width=900]

== C'est quoi le principe ?

image::dockerfile-flow.png[]

[%auto-animate]
== 🐋 📖🍳 Le livre de recettes

image::moby-kitchen.jpeg[]
image::dockerfile.png[]

[%auto-animate]
== 🐋 📖🍳 Le livre de recettes

image::dockerfile.png[]

[%auto-animate]
== 🐋 📖🍳 Le livre de recettes

image::dockerfile.png[]

Un simple fichier nommé "Dockerfile" (majuscule sur le D et pas d'extension).

[%auto-animate]
== 🐋 📖🍳 Le livre de recettes

image::dockerfile.png[]

Un simple fichier nommé "Dockerfile" (majuscule sur le D et pas d'extension).

C'est du texte, très pratique à stocker dans Git.

[%auto-animate]
== 🐋 📖🍳 Le livre de recettes

image::dockerfile.png[]

Un simple fichier nommé "Dockerfile" (majuscule sur le D et pas d'extension).

C'est du texte, très pratique à stocker dans Git.

Une suite de clef-valeur.

== 🤔 Pourquoi fabriquer sa propre image ?

❗️ Problème :

[source,bash]
----
cat /etc/os-release
# ...
git --version
# ...

# Même version de Linux que dans GitPod
docker container run --rm ubuntu:22.04 git --version
# docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: "git": executable file not found in $PATH: unknown.

# En interactif ?
docker container run --rm --tty --interactive ubuntu:22.04 git --version
----

== 🎓 Fabriquer sa première image

* *But :* fabriquer une image Docker qui contient `git`

* Dans votre workspace Gitpod, créez un dossier nommé `docker-git/`
* Dans ce dossier, créer un fichier `Dockerfile` avec le contenu ci-dessous :
+
[source,Dockerfile]
----
include::../code-samples/images/première-image/git/Dockerfile[]
----

* Fabriquez votre image avec la commande `docker image build --tag=docker-git chemin/vers/docker-git/`

* Testez l'image fraîchement fabriquée
** 💡 `docker image ls`

== ✅ Fabriquer sa première image

[source,bash]
----
cat <<EOF >Dockerfile
include::../code-samples/images/première-image/git/Dockerfile[]
EOF

docker image build --tag=docker-git ./

docker image ls | grep docker-git

# Doit fonctionner
docker container run --rm docker-git:latest git --version
----

[%auto-animate]
== 🐋 📖🍳 Fabriquer son image

Un peu de cuisine...

image::445636559-image7.gif[]

[%auto-animate]
== 🐋 📖🍳 Fabriquer son image

**💪🏁 DÉFI**

Créer une image alpine avec un JRE installé.

[%step]
**📖🍳 RECETTE**

[%step]
* On part d'une image Alpine
[%step]
* On installe un JRE

[%auto-animate]
== !

image::images-output52_with_transparency.png[background,size=contain]

[%auto-animate]
== !

image::images-output53_with_transparency.png[background,size=contain]

[%auto-animate]
== !

image::images-output54_with_transparency.png[background,size=contain]

[%auto-animate]
== !

image::images-output56_with_transparency.png[background,size=contain]

[.notes]
--
[source,bash]
----
for i in {52..56}; do convert Diapositive${i}.PNG -crop 9580x5224+1879+1795 -transparent white -resize x1080 images-output${i}_with_transparency.png; done
----
--

[%auto-animate]
[.columns]
== 🐋 📖🍳 Fabriquer son image

[.column]
--
image::images-output56_with_transparency.png[]
--

[.column]
--
[source,dockerfile]
----
include::../code-samples/images/defi/Dockerfile[]
----
--

[.notes]
--
[source,bash]
----
for i in {52..56}; do convert Diapositive${i}.PNG -crop 9580x5224+1879+1795 -transparent white -resize x1080 images-output${i}_with_transparency.png; done
----
--

[%auto-animate]
== 🐋 📖🍳 Cuistot, au boulot!

image::images-output57_with_transparency.png[]

[%auto-animate]
== 🐋 📖🍳 Cuistot, au boulot!

image::images-output58_with_transparency.png[]

[%auto-animate]
== 🐋 📖🍳 Cuistot, au boulot!

image::images-output59_with_transparency.png[]

[%auto-animate]
[.columns]
== 🐋 📖🍳 Cuistot, au boulot!

[.column]
--
image::images-output59_with_transparency.png[]
--

[.column]
--
[source,bash]
----
docker image build -t myjava:1.42 .
----
--

[.notes]
--
[source,bash]
----
docker image build -t myjava:1.42 .

----
--

[%auto-animate]
== 🪜 Étapes de construction

image::images-output60_with_transparency.png[]

[%auto-animate]
== 🪜 Étapes de construction

image::images-output61_with_transparency.png[]

[%auto-animate]
== 🪜 Étapes de construction

image::images-output62_with_transparency.png[]

[.notes]
--
[source,bash]
----
for i in {60..62}; do convert Diapositive${i}.PNG -crop 9068x5265+1920+1827 -transparent white -resize x1080 images-output${i}_with_transparency.png; done
----
--

== Et après ?

[%step]
Quand le build se termine, il se trouve dans le registre local.

[%step]
[source,bash]
----
docker images
REPOSITORY       TAG                 IMAGE ID
myjava           1.42                d3017f59d5e2
----

== L'image est dispo !

[%step]
[source,bash]
----
docker container run --interactive --tty myjava:1.42 sh
/ $
----

[%step]
[source,bash]
----
/ $ java -version
openjdk version "17.0.8" 2023-07-18
OpenJDK Runtime Environment (build 17.0.8+7-alpine-r0)
OpenJDK 64-Bit Server VM (build 17.0.8+7-alpine-r0, mixed mode, sharing)
----

[%step]
image::278458282-image10.gif[]

== Registre local, mais encore?

On les trouve où, ces images ?

[%step]
En local, on l'a vu.

[%step]
Dans les registres Docker.

[%step]
[source,bash]
----
$ docker images
REPOSITORY                            TAG                     IMAGE ID       CREATED         SIZE
cours-devops-docker-serve             latest                  654fc65c0913   13 hours ago    668MB
cours-devops-docker-qrcode            latest                  a3ff53e5d677   13 hours ago    668MB
cours-devops-docker-build             latest                  a8b5055c6b8a   13 hours ago    668MB
jenkins/jenkins                       2.504-slim-jdk17        2f264c295874   44 hours ago    669MB
jenkins/jenkins                       2.504-slim              4db3d90f94da   44 hours ago    691MB
jenkins/jenkins                       2.504-slim-jdk21        4db3d90f94da   44 hours ago    691MB
jenkins/jenkins                       2.504                   c6458a4308c9   44 hours ago    807MB
jenkins/jenkins                       2.504-jdk21             c6458a4308c9   44 hours ago    807MB
jenkins/jenkins                       2.504-jdk17             a44b80b5278d   44 hours ago    785MB
jenkins/jenkins                       2.504-jdk25             df290633b1b1   44 hours ago    709MB
jenkins/jenkins                       2.504-slim-jdk25        1b3e857e0e80   44 hours ago    593MB
jenkins/jenkins                       2.504-rhel-ubi9-jdk21   5bf47807e933   44 hours ago    807MB
jenkins/jenkins                       2.504-rhel-ubi9-jdk17   7c663bf36a0b   44 hours ago    785MB
jenkins/jenkins                       2.504-rhel-ubi9-jdk25   7ade79f2d5d6   44 hours ago    709MB
jenkins/jenkins                       2.504-alpine-jdk17      f8bb1d21d3b3   44 hours ago    458MB
jenkins/jenkins                       2.504-alpine            9796a49cd5ad   44 hours ago    480MB
jenkins/jenkins                       2.504-alpine-jdk21      9796a49cd5ad   44 hours ago    480MB
jenkins/jenkins                       2.504-alpine-jdk25      713be11d8079   44 hours ago    384MB
tomcat                                9.0                     bfe8385d954f   4 days ago      608MB
tomcat                                latest                  2b3894dce12e   4 days ago      607MB
img1758726197                         latest                  69b8e1bd3710   6 days ago      259MB
ubuntu                                latest                  9cbed7541129   6 weeks ago     117MB
nginx                                 latest                  d5f28ef21aab   6 weeks ago     279MB
hello-world                           latest                  54e66cc1dd1f   7 weeks ago     20.3kB
alpine                                latest                  4bcff63911fc   2 months ago    12.8MB
<none>                                <none>                  8feb4d8ca535   5 months ago    109MB
moby/buildkit                         buildx-stable-1         14aa1b4dd92e   8 months ago    306MB
ghcr.io/jenkinsci/ssh-agents-plugin   baseb2fb086             2bc6d82ca2b4   9 months ago    1.36GB
<none>                                <none>                  dfa54ef35e43   21 months ago   6.89MB
registry                              2                       a3d8aaa63ed8   24 months ago   37.2MB
jboss/wildfly                         latest                  35320abafdec   3 years ago     1.17GB
----

== Les registres Docker

Ce sont des plates-formes qui hébergent les images.

Il est possible de créer ses propres registres (ex : registre privé d'entreprise)

== !

image::node_Official_Image_Docker_Hub.png[background, size=cover, position=left, opacity=0.1]

[.notes]
--
https://hub.docker.com/
--

== 🖼️ Les images

Avant d'instancier un container, il faut récupérer l'image en local.

[%step]
Méthode explicite :
[%step]
[source,bash]
----
docker image pull mysql
----

[%step]
[.small]
On rapatrie l'image en local mais on n'en fait rien.

[%step]
Méthode implicite :
[%step]
[source,bash]
----
docker container run -d mysql
----

[%step]
[.small]
On rapatrie l'image et on démarre un container dans la foulée.

== 🍰 Un téléchargement par couches

[%step]
[source,bash]
----
$ docker image pull mysql
Using default tag: latest
latest: Pulling from library/mysql
5f70bf18a086: Pull complete
a734b0ff4ca6: Already exists
ec46eb0ce0a7: Pull complete
a74b383379bc: Pull complete
Digest: sha256:42dc1b67073f7ebab1...8c8d36c9031e408db0d
Status: Downloaded newer image for mysql:latest
----

[%step]
Les couches déjà présentes en local ne sont pas téléchargées de nouveau !

[%auto-animate]
== 🖼🏷️ Conventions de nommage des images

image::images-output26_with_transparency.png[]


[%auto-animate]
== 🖼🏷️ Conventions de nommage des images

image::images-output27_with_transparency.png[]


[%auto-animate]
== 🖼🏷️ Conventions de nommage des images

image::images-output28_with_transparency.png[]

[%auto-animate]
== 🖼🏷️ Conventions de nommage des images

image::images-output29_with_transparency.png[]

[.notes]
--
[source,bash]
----
for i in {26..29}; do convert Diapositive${i}.PNG -crop 8962x4645+2183+2192 -transparent white -resize x1080 images-output${i}_with_transparency.png; done
----
--

[%auto-animate]
== !

image::images-output31_with_transparency.png[background,size=contain]

[%auto-animate]
== !

image::images-output32_with_transparency.png[background,size=contain]

[%auto-animate]
== !

image::images-output33_with_transparency.png[background,size=contain]

[%auto-animate]
== !

image::images-output34_with_transparency.png[background,size=contain]

[.notes]
--
[source,bash]
----
for i in {31..34}; do convert Diapositive${i}.PNG -crop 8904x5130+2256+2006 -transparent white -resize x1080 images-output${i}_with_transparency.png; done
----
--

== 📷🏷️ Conventions de nommage des images

[%step]
Une même image peut avoir plusieurs noms et tags !

[%step]
Le tag "latest" est régulièrement réaffecté sur les registres distants.

[%step]
**Plusieurs noms pour une signature**

== !

image::different_labels_same_checksum.png[background,size=contain]

== 📷🏷️ Conventions de nommage des images

Une même image peut avoir plusieurs noms et tags !

Le tag "latest" est régulièrement réaffecté sur les registres distants.

**Plusieurs noms pour une signature**

**Tags disponibles pour MySQL**

image::mysql_tags.png[width=1900]


== 📷🏷️ Conventions de nommage des images

Pour résumer...

[%step]
[source, plaintext]
----
[REGISTRY/][NAMESPACE/]NAME[:TAG|@DIGEST]
----

[%step]
* Pas de Registre ? Défaut: `registry.docker.com`
[%step]
* Pas de Namespace ? Défaut: `library`
[%step]
* Pas de tag ? Valeur par défaut: `latest`
[%step]
** ⚠️ Friends don't let friends use `latest` 👫
[%step]
* Digest: signature unique basée sur le contenu

== 📷🏷️ Conventions de nommage : Exemples

* `ubuntu:22.04` => `registry.docker.com/library/ubuntu:22.04`
* `dduportal/docker-asciidoctor` => `registry.docker.com/dduportal/docker-asciidoctor:latest`
* `ghcr.io/dduportal/docker-asciidoctor:1.3.2@sha256:xxxx`

== 🎓 Utilisons les tags

* Rappel : ⚠️ Friends don't let friends use `latest` 👫

* Il est temps de "taguer" votre première image !
+
[source,bash]
----
docker image tag docker-git:latest docker-git:1.0.0
----

* Testez le fonctionnement avec le nouveau tag
* Comparez les 2 images dans la sortie de `docker image ls`

== ✅ Utilisons les tags

[source,bash]
----
docker image tag docker-git:latest docker-git:1.0.0

# 2 lignes
docker image ls | grep docker-git
# 1 ligne
docker image ls | grep docker-git | grep latest
# 1 ligne
docker image ls | grep docker-git | grep '1.0.0'

# Doit fonctionner
docker container run --rm docker-git:1.0.0 git --version
----

== 🎓 Mettre à jour votre image (1.1.0)

* Mettez à jour votre image en version `1.1.0` avec les changements suivants :
** Ajoutez un https://docs.docker.com/engine/reference/builder/#label[`LABEL`,window="_blank"] dont la clef est `description` (et la valeur de votre choix)
** Configurez `git` pour utiliser une branche `main` par défaut au lieu de `master` (commande `git config --global init.defaultBranch main`)

* Indices :
** 💡 Commande `docker image inspect <image name>`
** 💡 Commande `git config --get init.defaultBranch` (dans le conteneur)
** 💡 Ajoutez des lignes *à la fin* du `Dockerfile`
** 💡 https://docs.docker.com/engine/reference/builder/[Documentation de référence des `Dockerfile`,window="_blank"]

== ✅ Mettre à jour votre image (1.1.0)

[source,bash]
----
cat ./Dockerfile
FROM ubuntu:22.04
RUN apt-get update && apt-get install --yes --no-install-recommends git
LABEL description="Une image contenant git préconfiguré"
RUN git config --global init.defaultBranch main

docker image build -t docker-git:1.1.0 ./docker-git/
# Sending build context to Docker daemon  2.048kB
# Step 1/4 : FROM ubuntu:22.04
#  ---> e40cf56b4be3
# Step 2/4 : RUN apt-get update && apt-get install --yes --no-install-recommends git
#  ---> Using cache
#  ---> 926b8d87f128
# Step 3/4 : LABEL description="Une image contenant git préconfiguré"
#  ---> Running in 0695fc62ecc8
# Removing intermediate container 0695fc62ecc8
#  ---> 68c7d4fb8c88
# Step 4/4 : RUN git config --global init.defaultBranch main
#  ---> Running in 7fb54ecf4070
# Removing intermediate container 7fb54ecf4070
#  ---> 2858ff394edb
Successfully built 2858ff394edb
Successfully tagged docker-git:1.1.0

docker container run --rm docker-git:1.0.0 git config --get init.defaultBranch
docker container run --rm docker-git:1.1.0 git config --get init.defaultBranch
# main
----

== Cache d'images & Layers

[source, plaintext]
----
Step 2/4 : RUN apt-get update && apt-get install --yes --no-install-recommends git
  ---> Using cache
----

🤔 En fait, Docker n'a PAS exécuté cette commande la seconde fois => ça va beaucoup plus vite !

image::docker-layers.jpg[width=400]

🎓 Essayez de voir les layers avec (dans Gitpod) https://github.com/wagoodman/dive[`dive <image>:<tag>`,window="_blank"]

== 🎓 Cache d'images & Layers

* *But :* manipuler le cache d'images

* Commencez par vérifier que le cache est utilisé : relancez la dernière commande `docker image build` (plusieurs fois s'il le faut)

* Invalidez le cache en ajoutant le paquet APT `make` à installer en même temps que `git`
** ⚠️ Tag `1.2.0`

* Vérifiez que le cache est bien présent de nouveau

== ✅ Cache d'images & Layers

[source,bash]
----
# Build one time
docker image build -t docker-git:1.1.0 ./docker-git/
# Second time is fully cached
docker image build -t docker-git:1.1.0 ./docker-git/

cat Dockerfile
# FROM ubuntu:22.04
# RUN apt-get update && apt-get install --yes --no-install-recommends git make
# LABEL description="Une image contenant git préconfiguré"
# RUN git config --global init.defaultBranch main

# Build one time
docker image build -t docker-git:1.2.0 ./docker-git/
# Second time is fully cached
docker image build -t docker-git:1.2.0 ./docker-git/

## Vérification
# Renvoie une erreur
docker run --rm docker-git:1.1.0 make --version
# Doit fonctionner
docker run --rm docker-git:1.2.0 make --version
----

include::sous-chapitres/images/entrypoint.adoc[]


== Checkpoint 🎯

* Une image Docker fournit un environnement de système de fichier auto-suffisant (application, dépendances, binaries, etc.) comme modèle de base d'un conteneur

* Les images Docker ont une convention de nommage permettant d'identifier les images très précisément

* On peut spécifier une recette de fabrication d'image à l'aide d'un `Dockerfile` et de la commande `docker image build`

=> 🤔 et si on utilisait Docker pour nous aider dans l'intégration continue ?
