[background-color="Navy"]
= SÃ©curitÃ© et Production Docker

image::security-production-header.png[height=400px]

[.notes]
--
DurÃ©e totale : 3 heures
Session pratique avec projet fil rouge SecureVote
--

== Objectifs de la session

[%step]
* Comprendre et appliquer les bonnes pratiques de sÃ©curitÃ© Docker
* Optimiser les conteneurs pour la production
* GÃ©rer les registres d'images Docker
* DÃ©ployer une application sÃ©curisÃ©e et production-ready

[.notes]
--
Cette session est entiÃ¨rement basÃ©e sur un projet fil rouge : SecureVote
Les Ã©tudiants partent d'une version fonctionnelle mais dangereuse
Ils la transforment progressivement en dÃ©ploiement production-ready
--

[background-color="MediumBlue"]
== Projet Fil Rouge : SecureVote

SecureVote : Une application de vote en ligne moderne

[%step]
* Frontend React (interface de vote)
* Backend API Python Flask
* Base de donnÃ©es PostgreSQL
* Redis pour le cache
* Nginx comme reverse proxy

**DÃ©pÃ´t GitHub :** https://github.com/gounthar/securevote

[.notes]
--
Cette application reprÃ©sente un cas d'usage rÃ©aliste : une stack web complÃ¨te typique des applications modernes.
L'aspect "vote" rend le projet concret et engageant.
Les Ã©tudiants vont manipuler 5 technologies diffÃ©rentes, ce qui reflÃ¨te la rÃ©alitÃ© du DevOps.
Insister sur le fait que c'est LEUR projet pour les 3 heures : ils vont le faire Ã©voluer eux-mÃªmes.

**STACK TECHNIQUE EXPLIQUÃ‰E :**

â€¢ **Flask (Python)** : Framework web lÃ©ger pour API REST. Alternative Ã  Django (plus lourd), Express.js (Node), ou Spring (Java).
  - TrÃ¨s utilisÃ© pour des APIs rapides et microservices
  - Langage : Python (facile Ã  lire mÃªme sans le connaÃ®tre)
  - Port : 5000 par dÃ©faut
  - RÃ´le ici : GÃ¨re les requÃªtes HTTP (GET /votes, POST /vote), connexion DB, logique mÃ©tier

â€¢ **React (JavaScript)** : BibliothÃ¨que JavaScript pour interfaces utilisateur (pas un framework complet comme Angular ou Vue).
  - DÃ©veloppÃ© par Facebook, trÃ¨s populaire (Netflix, Airbnb, etc.)
  - Langage : JavaScript/JSX
  - Port : 3000 en dÃ©veloppement (webpack dev server)
  - RÃ´le ici : Affiche l'interface de vote, boutons, rÃ©sultats en temps rÃ©el

â€¢ **PostgreSQL** : Base de donnÃ©es relationnelle robuste (alternative open-source Ã  Oracle, MySQL).
  - Stockage persistant des donnÃ©es
  - Port : 5432 par dÃ©faut
  - RÃ´le ici : Stocke les votes, les options de vote, les rÃ©sultats

â€¢ **Redis** : Base de donnÃ©es en mÃ©moire ultra-rapide, utilisÃ©e comme cache.
  - PrononcÃ© "RED-iss" (Remote Dictionary Server)
  - Port : 6379 par dÃ©faut
  - RÃ´le ici : Cache les rÃ©sultats de vote pour Ã©viter de requÃªter PostgreSQL Ã  chaque fois (performance !)

â€¢ **Nginx** : Serveur web et reverse proxy trÃ¨s performant (concurrent d'Apache).
  - PrononcÃ© "engine-x"
  - Port : 80 (HTTP) / 443 (HTTPS)
  - RÃ´le ici : Point d'entrÃ©e unique, route les requÃªtes vers frontend (/) ou backend (/api)

**POURQUOI CETTE STACK ?** C'est une architecture moderne typique : frontend SPA (Single Page App) + API REST + DB + cache + reverse proxy.
On la retrouve chez des entreprises comme Uber, Spotify, Instagram (avec des variations).
--

== Architecture de l'application

[source,yaml]
----
services:
  frontend:    # React app
  backend:     # Flask API
  database:    # PostgreSQL
  cache:       # Redis
  proxy:       # Nginx
----

Architecture multi-tiers classique pour DevOps

[.notes]
--
Architecture en 5 services : c'est suffisamment complexe pour Ãªtre intÃ©ressant, mais pas trop pour 3h.
Proxy en point d'entrÃ©e unique : seul port exposÃ© en prod, pattern essentiel Ã  comprendre.
Cache Redis : montre l'importance de la performance en production.
Cette architecture se retrouve dans 80% des applications web modernes.

**COMMENT LES COMPOSANTS COMMUNIQUENT :**

1. **Utilisateur â†’ Nginx (port 8080)** : L'utilisateur accÃ¨de Ã  http://localhost:8080
   - Nginx reÃ§oit TOUTES les requÃªtes (le "portier" de l'application)

2. **Nginx â†’ Frontend (port 3000)** : Pour les pages web (/, /index.html, /static/...)
   - Nginx fait du "proxy_pass" : il redirige la requÃªte vers React
   - React retourne du HTML/CSS/JavaScript

3. **Nginx â†’ Backend (port 5000)** : Pour les requÃªtes API (/api/...)
   - Exemple : POST /api/vote â†’ Nginx redirige vers Flask
   - Flask traite la logique et retourne du JSON

4. **Backend â†’ Database (port 5432)** : Flask se connecte Ã  PostgreSQL
   - Utilise le driver psycopg2 (bibliothÃ¨que Python pour PostgreSQL)
   - Exemples : INSERT INTO votes, SELECT COUNT(*) FROM votes

5. **Backend â†’ Cache (port 6379)** : Flask interroge Redis en premier
   - Si donnÃ©e en cache â†’ retour immÃ©diat (rapide !)
   - Si pas en cache â†’ requÃªte PostgreSQL + mise en cache pour la prochaine fois

**AVANTAGES DE CETTE ARCHITECTURE :**
- **SÃ©paration des responsabilitÃ©s** : chaque service a un rÃ´le clair
- **ScalabilitÃ©** : on peut dupliquer frontend/backend indÃ©pendamment
- **SÃ©curitÃ©** : seul Nginx est exposÃ©, les autres services sont internes
- **Performance** : Redis Ã©vite de surcharger PostgreSQL

**EN PHASE 1** : Tous les ports sont exposÃ©s (5432, 6379, 5000, 3000, 8080) = VULNÃ‰RABILITÃ‰ !
**EN PHASE 2/3** : Seul le port 8080 (Nginx) est exposÃ©, le reste est interne.
--

== Votre mission

[%step]
* **Phase 1** (30 min) : DÃ©marrer l'application "dangereuse"
* **Phase 2** (1h15) : SÃ©curiser l'application
* **Phase 3** (1h) : Optimiser pour la production

[%step]
WARNING: L'application initiale contient de nombreuses vulnÃ©rabilitÃ©s volontaires !

[background-color="DarkRed"]
== Phase 1 : DÃ©couverte (30 min)

[source,bash]
----
git clone https://github.com/gounthar/securevote.git
cd securevote/phase1
docker compose up -d

# VÃ©rifier l'Ã©tat des services
docker compose ps

# Suivre les logs (Ctrl+C pour quitter)
docker compose logs -f
----

[%step]
* **Attendre** que tous les services soient UP (~30 secondes)
* AccÃ©dez Ã  http://localhost:8080
* Testez l'application de vote

[.notes]
--
Phase cruciale : les Ã©tudiants doivent DÃ‰COUVRIR eux-mÃªmes les vulnÃ©rabilitÃ©s.
IMPORTANT : Backend peut prendre 10-20s Ã  dÃ©marrer â†’ nginx redÃ©marre automatiquement aprÃ¨s.
Si "host not found in upstream" dans logs nginx : c'est NORMAL, attendre 30s.
Ne pas leur donner les rÃ©ponses tout de suite - les laisser chercher 5-10 minutes.
L'application FONCTIONNE : c'est volontaire, montrer qu'une app vulnÃ©rable peut sembler normale.
Circuler entre les groupes : certains vont paniquer si nginx redÃ©marre.
--

== Analyse des vulnÃ©rabilitÃ©s

Explorez les fichiers et identifiez les problÃ¨mes :

[%step]
* Qui exÃ©cute les conteneurs ?
* OÃ¹ sont stockÃ©s les secrets ?
* Les images sont-elles Ã  jour ?
* Y a-t-il des ports exposÃ©s inutilement ?

== Points d'attention

**Ã€ vÃ©rifier :**

[%step]
* `docker compose ps`
* `docker inspect <container>`
* Contenu des Dockerfile
* Variables d'environnement

[%step]
**Questions :** Quels risques identifiez-vous ? Comment exploiter ces failles ?

[background-color="OrangeRed"]
== SÃ©curitÃ© Docker : Les fondamentaux

Les 3 piliers de la sÃ©curitÃ© Docker :

[%step]
. **Images sÃ»res** : Bases fiables, sans vulnÃ©rabilitÃ©s
. **Runtime sÃ©curisÃ©** : Isolation, utilisateurs non-root
. **Secrets protÃ©gÃ©s** : Pas de mots de passe en clair

[.notes]
--
Framework simple pour mÃ©moriser : 3 piliers = 3 zones d'intervention.
Images = la BASE, si elle est pourrie, tout le reste est compromis.
Runtime = pendant l'exÃ©cution, principe du moindre privilÃ¨ge.
Secrets = la donnÃ©e la plus sensible, jamais en clair.
Cette structure va guider toute la Phase 2.
--

== Principe du moindre privilÃ¨ge

[quote]
____
Un conteneur ne devrait avoir QUE les permissions nÃ©cessaires Ã  son fonctionnement
____

[%step]
* Pas d'exÃ©cution en tant que root
* CapacitÃ©s Linux minimales
* SystÃ¨me de fichiers en lecture seule quand possible
* RÃ©seau isolÃ©

== Scan de vulnÃ©rabilitÃ©s

Les images Docker peuvent contenir des vulnÃ©rabilitÃ©s connues (CVE)

**Outils de scan :**

[%step]
* Docker Scout (intÃ©grÃ© Ã  Docker Desktop)
* Trivy (open source, trÃ¨s populaire)
* Snyk, Grype

== Docker Scout en action

[source,bash]
----
# Scanner une image locale
docker scout cves python:3.11

# Comparer deux images
docker scout compare python:3.11 --to python:3.11-slim
----

TIP: DÃ©monstration live recommandÃ©e

[.notes]
--
DÃ‰MONSTRATION LIVE ESSENTIELLE ici ! Les Ã©tudiants doivent VOIR les CVE en temps rÃ©el.
Comparer python:3.11 vs python:3.11-slim : diffÃ©rence spectaculaire (150+ CVE vs 20-30).
Si Docker Scout ne fonctionne pas, basculer sur Trivy : "docker run aquasec/trivy image python:3.11"
Montrer que le scan prend 10-30 secondes : c'est acceptable pour un pipeline CI/CD.
Insister : ce n'est pas paranoÃ¯aque, c'est STANDARD en 2025.
--

== Installation de Trivy

**MÃ©thode recommandÃ©e pour le TP :**

[source,bash]
----
# Installation directe du binaire (fonctionne partout)
curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin

# VÃ©rifier l'installation
trivy --version
----

[%step]
TIP: Cette mÃ©thode fonctionne sur toutes les distributions Linux

[.notes]
--
Script d'installation : tÃ©lÃ©charge et installe le binaire dans /usr/local/bin.
Fonctionne sur toutes les distributions : Debian (y compris Trixie), Ubuntu, RHEL, etc.
Toujours la derniÃ¨re version stable.
Sur Debian Trixie/Testing : c'est LA mÃ©thode Ã  utiliser (le repo apt ne supporte pas encore trixie).
--

== Installation Trivy : Alternatives

**Si vous n'avez pas les droits sudo :**

[source,bash]
----
# Via Docker (aucune installation nÃ©cessaire)
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  aquasec/trivy image python:3.11
----

**Autres systÃ¨mes :**

[%step]
* **macOS :** `brew install trivy`
* **Debian/Ubuntu stable :** Via apt (voir documentation)

[.notes]
--
**MÃ‰THODE DOCKER :**
- Aucune installation nÃ©cessaire
- Garantit que tout le monde a la mÃªme version
- Peut Ãªtre plus lent la premiÃ¨re fois (tÃ©lÃ©charge l'image)
- Syntaxe un peu plus longue

**CHOIX POUR LE TP :**
- DÃ©monstration enseignant : script d'installation (rapide, propre)
- Ã‰tudiants : script d'installation OU Docker selon permissions
- PremiÃ¨re utilisation : le scan sera lent (~30s) car tÃ©lÃ©charge la base CVE (~200 Mo)
- Mise Ã  jour de la base : `trivy image --download-db-only`

**TROUBLESHOOTING :**
- Permission denied â†’ Ajouter sudo ou utiliser mÃ©thode Docker
- Erreur "trixie Release not found" (si tentative apt) â†’ Utiliser le script
--

== Exemple de rÃ©sultat Trivy

[source,bash]
----
trivy image python:3.11

Total: 145 vulnerabilities (52 HIGH, 93 MEDIUM)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Library  â”‚ Vulnerabilityâ”‚ Severity â”‚ Version â”‚
â”‚ openssl  â”‚ CVE-2023-XXX â”‚ HIGH     â”‚ 1.1.1n  â”‚
â”‚ curl     â”‚ CVE-2023-YYY â”‚ MEDIUM   â”‚ 7.68.0  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

[%step]
**Action :** Mettre Ã  jour, changer d'image de base, appliquer des patches

== Utilisateurs non-root

**ProblÃ¨me :** Par dÃ©faut, les processus s'exÃ©cutent en tant que root

[source,dockerfile]
----
FROM python:3.11
COPY app.py /app/
CMD ["python", "/app/app.py"]  # Root !
----

WARNING: Si compromis, l'attaquant a les privilÃ¨ges root !

[.notes]
--
Erreur NÂ°1 des dÃ©butants Docker : tout tourne en root par dÃ©faut.
Analogie : c'est comme lancer toutes vos apps Windows en "Administrateur" en permanence.
Si un attaquant exploite une faille dans votre app Python, il a root sur le conteneur.
Avec root, il peut : installer des outils, scanner le rÃ©seau, pivoter vers d'autres conteneurs.
Montrer docker exec <container> whoami â†’ retourne "root" = MAUVAIS !
--

== Solution : Utilisateur dÃ©diÃ©

[source,dockerfile]
----
FROM python:3.11-slim

RUN groupadd -r appuser && useradd -r -g appuser appuser
WORKDIR /app
COPY app.py /app/
RUN chown -R appuser:appuser /app

USER appuser
CMD ["python", "/app/app.py"]
----

== Bonnes pratiques utilisateur

[%step]
* Toujours crÃ©er un utilisateur dÃ©diÃ©
* UID > 1000 (Ã©viter conflits systÃ¨me)
* Ne jamais revenir Ã  root aprÃ¨s USER
* VÃ©rifier : `docker exec <container> whoami`

== Comprendre les UID Linux

Linux numÃ©rote les utilisateurs (User ID) :

[%step]
* **UID 0** : root (super-utilisateur)
* **UID 1-999** : comptes systÃ¨me (www-data, postgres, redis...)
* **UID â‰¥ 1000** : utilisateurs normaux et applications

[%step]
WARNING: Avec volumes montÃ©s, UID < 1000 peut crÃ©er des conflits de sÃ©curitÃ© !

[.notes]
--
**POURQUOI C'EST IMPORTANT :**

Si vous crÃ©ez un utilisateur avec UID 33 (www-data) dans votre conteneur,
et que l'hÃ´te a AUSSI www-data (UID 33), le conteneur pourra accÃ©der aux fichiers
de www-data sur l'HÃ”TE via les volumes montÃ©s = faille de sÃ©curitÃ© !

**BONNE PRATIQUE :**
- Sans volumes montÃ©s : `useradd -r` acceptable (crÃ©e UID systÃ¨me < 1000)
- Avec volumes montÃ©s : `useradd -u 1001` ou laisser le systÃ¨me choisir (â‰¥ 1000)

Dans SecureVote, `-r` est acceptable car pas de volumes montÃ©s critiques avec l'hÃ´te.
--

== UID : Exemple pratique

[source,dockerfile]
----
# RISQUÃ‰ : UID fixe < 1000
RUN useradd -u 33 appuser
# Conflit possible si l'hÃ´te a www-data (UID 33) !

# SÃ›R : UID > 1000
RUN useradd -u 1001 appuser

# OU laisser le systÃ¨me choisir (sera â‰¥ 1000)
RUN useradd appuser
----

[%step]
VÃ©rifier : `docker exec <container> id appuser`

[.notes]
--
Montrer la commande `id` dans un conteneur pour voir l'UID assignÃ©.
Exemple de rÃ©sultat : uid=1001(appuser) gid=1001(appuser) groups=1001(appuser)

Pour les Ã©tudiants : expliquer que c'est comme les numÃ©ros de tÃ©lÃ©phone -
il faut Ã©viter que deux personnes aient le mÃªme numÃ©ro !

L'option `-r` dans `useradd -r` crÃ©e un "system user" avec UID < 1000.
C'est historique : les services systÃ¨me (Apache, Nginx, PostgreSQL) utilisent des UID bas.
--

== Gestion des secrets

**Mauvaise pratique :**

[source,yaml]
----
environment:
  - POSTGRES_PASSWORD=super_secret_123  # NON !
----

WARNING: Visible dans `docker inspect`, logs, historique !

[.notes]
--
PiÃ¨ge classique : secrets en clair dans docker-compose.yml = COMMITÃ‰S sur Git = PUBLICS.
Anecdote : chercher "removed password" sur GitHub = des millions de rÃ©sultats.
Les secrets restent dans l'historique Git mÃªme aprÃ¨s suppression !
docker inspect montre TOUTES les variables d'env = un attaquant peut lire.
Les logs peuvent accidentellement afficher les secrets lors du dÃ©marrage.
Message clÃ© : les secrets ne doivent JAMAIS Ãªtre versionnÃ©s.
--

== Bonne pratique : Fichiers .env

**Ã‰tape 1 : CrÃ©er le fichier .env**

[source,bash]
----
# .env (Ã  ne JAMAIS commiter)
DB_PASSWORD=super_secret_123
----

**Ã‰tape 2 : ProtÃ©ger avec .gitignore**

[source,bash]
----
# .gitignore
.env
secrets/
----

**Ã‰tape 3 : Utiliser dans docker-compose.yml**

[source,yaml]
----
environment:
  - POSTGRES_PASSWORD=${DB_PASSWORD}
----

TIP: Docker Compose charge automatiquement le fichier .env

== Alternative 1 : Docker Secrets

**Gestion native dans Docker Swarm**

[%step]
* Secrets cryptÃ©s dans le cluster Swarm
* MontÃ©s en RAM dans `/run/secrets/`
* AccÃ¨s contrÃ´lÃ© par service

[source,bash]
----
echo "secret123" | docker secret create db_password -
docker service create --secret db_password postgres
----

[.notes]
--
**DOCKER SECRETS - GUIDE DÃ‰TAILLÃ‰**

Qu'est-ce que c'est ?
- SystÃ¨me de gestion de secrets intÃ©grÃ© Ã  Docker Swarm (orchestrateur Docker natif)
- Secrets stockÃ©s cryptÃ©s dans le cluster Swarm
- MontÃ©s comme fichiers dans /run/secrets/ (en RAM, jamais sur disque)
- Les secrets ne transitent JAMAIS sur le disque dur, toujours en mÃ©moire

**Avantages :**
âœ… Natif Docker, pas de service externe Ã  installer
âœ… CryptÃ© au repos et en transit (TLS mutuel entre nÅ“uds)
âœ… AccÃ¨s contrÃ´lÃ© par service (seuls les services autorisÃ©s peuvent lire)
âœ… Rotation possible (crÃ©er nouveau secret, redÃ©ployer service)
âœ… Gratuit, inclus dans Docker

**InconvÃ©nients :**
âŒ NÃ©cessite Docker Swarm (pas Compose standalone ou Kubernetes)
âŒ Moins de fonctionnalitÃ©s que Vault (pas de rotation automatique, audit limitÃ©)
âŒ Courbe d'apprentissage Swarm si vous utilisez Compose

**Comment Ã§a fonctionne :**
1. CrÃ©er le secret : `docker secret create db_password secret.txt`
2. Attribuer au service : `docker service create --secret db_password myapp`
3. Application lit `/run/secrets/db_password` (fichier en RAM)

**Quand l'utiliser :**
- Environnements Docker Swarm en production
- Petites/moyennes infrastructures (5-50 conteneurs)
- Alternative simple Ã  Vault pour dÃ©buter
- Besoin de secrets cryptÃ©s sans infrastructure externe

**Pour SecureVote :**
Non utilisÃ© dans le TP (on reste sur Compose), mais Ã©volution possible si migration vers Swarm.
--

== Alternative 2 : HashiCorp Vault

**Solution d'entreprise pour secrets**

[%step]
* Serveur centralisÃ© avec API REST
* Rotation automatique des credentials
* Audit complet et secrets dynamiques

[source,bash]
----
# Application interroge Vault via API
vault kv get -field=password secret/database/prod
----

[%step]
WARNING: NÃ©cessite infrastructure dÃ©diÃ©e (serveur Vault)

[.notes]
--
**VAULT - SOLUTION ENTERPRISE**

Qu'est-ce que c'est ?
- Solution d'entreprise dÃ©diÃ©e Ã  la gestion de secrets (HashiCorp)
- Serveur centralisÃ© de secrets avec API REST
- Audit complet, rotation automatique, durÃ©e de vie des secrets
- "Fort Knox" des secrets : le standard de l'industrie

**Avantages :**
âœ… Solution la plus complÃ¨te du marchÃ©
âœ… Rotation automatique des secrets (DB credentials, API keys, certificats)
âœ… Audit trail complet (qui a accÃ©dÃ© Ã  quoi, quand, depuis oÃ¹)
âœ… Secrets dynamiques (gÃ©nÃ¨re des credentials temporaires Ã  la demande)
âœ… IntÃ©gration avec cloud providers (AWS, Azure, GCP)
âœ… Fonctionne avec Docker Compose, Swarm, Kubernetes, VMs
âœ… Versioning des secrets (rollback possible)
âœ… Policies granulaires (contrÃ´le d'accÃ¨s fin)

**InconvÃ©nients :**
âŒ Infrastructure supplÃ©mentaire Ã  gÃ©rer (serveur Vault Ã  maintenir, haute dispo)
âŒ Courbe d'apprentissage Ã©levÃ©e (concepts : policies, auth methods, engines)
âŒ CoÃ»t version enterprise pour features avancÃ©es (namespaces, rÃ©plication)
âŒ ComplexitÃ© opÃ©rationnelle (unsealing, backup, disaster recovery)

**Exemple concret :**
```bash
# Vault gÃ©nÃ¨re des credentials MySQL temporaires (valides 1h)
vault read database/creds/myapp
# Key            Value
# lease_id       database/creds/myapp/abcd1234
# username       v-myapp-abc123
# password       A1b2C3d4...
```

**Quand l'utiliser :**
- Grandes organisations avec 100+ secrets Ã  gÃ©rer
- Exigences de compliance strictes (SOC2, ISO27001, PCI-DSS)
- Multi-cloud ou infrastructure hybride (secrets partagÃ©s)
- Besoin de secrets dynamiques (ex: credentials DB temporaires pour chaque dÃ©ploiement)
- Ã‰quipe dÃ©diÃ©e Ã  la sÃ©curitÃ©/infrastructure

**CoÃ»t/Ressources :**
- Open source : gratuit mais features limitÃ©es
- Enterprise : $$$ (Ã  partir de 15k$/an pour petite org)
- NÃ©cessite : 1-2 personnes dÃ©diÃ©es pour l'opÃ©rationnel

**Pour SecureVote :**
Overkill pour le TP. Mentionner comme Ã©volution si l'application devient un service SaaS avec 1000+ clients.
--

== Alternative 3 : Cloud Providers

**Services managÃ©s AWS / Azure / GCP**

[%step]
* **AWS Secrets Manager** : intÃ©gration RDS/Aurora
* **Azure Key Vault** : intÃ©gration Azure AD, HSM
* **GCP Secret Manager** : intÃ©gration Cloud Run/GKE

[%step]
âœ… EntiÃ¨rement managÃ©, haute disponibilitÃ©
âŒ Vendor lock-in, coÃ»t Ã  l'usage

[.notes]
--
**CLOUD PROVIDERS - SERVICES MANAGÃ‰S**

Qu'est-ce que c'est ?
- Services managÃ©s de gestion de secrets par les cloud providers
- IntÃ©gration native avec les autres services du cloud
- ZÃ©ro maintenance, facturation Ã  l'usage

**Les 3 grands providers :**

**1. AWS Secrets Manager**
- Rotation automatique pour RDS, Aurora, Redshift, DocumentDB
- IntÃ©gration native avec Lambda, ECS, EC2 via IAM roles
- Versioning automatique des secrets
- CoÃ»t : ~0.40$/secret/mois + 0.05$/10k requÃªtes

**2. Azure Key Vault**
- IntÃ©gration avec Azure AD pour l'authentification
- HSM hardware optionnel (clÃ©s stockÃ©es dans modules cryptographiques certifiÃ©s)
- Managed identities pour AKS, App Service, Functions
- CoÃ»t : ~0.03$/secret/mois + 0.03$/10k opÃ©rations

**3. GCP Secret Manager**
- IntÃ©gration native avec Cloud Run, GKE, Cloud Functions
- RÃ©plication multi-rÃ©gion automatique
- Audit via Cloud Logging
- CoÃ»t : ~0.06$/secret/mois + 0.03$/10k accÃ¨s

**Avantages :**
âœ… EntiÃ¨rement managÃ© (pas de serveur Ã  maintenir, pas de patching)
âœ… IntÃ©gration native avec services cloud (IAM, load balancers, etc.)
âœ… Rotation automatique pour certains services (RDS sur AWS, etc.)
âœ… Haute disponibilitÃ© garantie par le provider (SLA 99.9%+)
âœ… Audit via CloudTrail / Azure Monitor / Cloud Logging
âœ… Facile Ã  dÃ©marrer (quelques clics dans la console)

**InconvÃ©nients :**
âŒ Vendor lock-in (difficile de migrer vers autre cloud)
âŒ CoÃ»t Ã  l'usage (peut devenir cher avec 1000+ secrets)
âŒ Moins flexible que Vault pour du multi-cloud
âŒ Features variables selon provider (AWS plus complet que GCP)

**Comparaison des coÃ»ts (exemple 100 secrets, 1M requÃªtes/mois) :**
- AWS : ~40$ + 5$ = 45$/mois
- Azure : ~3$ + 3$ = 6$/mois
- GCP : ~6$ + 30$ = 36$/mois
- Vault self-hosted : ~200$/mois (serveur) + temps Ã©quipe

**Quand l'utiliser :**
- Infrastructure dÃ©jÃ  sur un cloud public (AWS, Azure, GCP)
- Pas d'Ã©quipe dÃ©diÃ©e pour gÃ©rer un Vault
- Budget pour services managÃ©s
- Besoin d'intÃ©gration native avec services cloud
- Startup/PME qui veut se concentrer sur le produit, pas l'infra

**Pour SecureVote :**
Si dÃ©ploiement sur AWS/Azure/GCP â†’ excellent choix. Plus simple que Vault, pas de maintenance.
--

== Alternative 4 : Variables shell

**Passage direct via environnement**

[%step]
* Simple pour dev et CI/CD
* Secrets injectÃ©s au runtime

[source,bash]
----
# En une ligne
DB_PASSWORD="secret123" docker compose up -d

# Ou via export
export DB_PASSWORD="secret123"
docker compose up -d
----

[%step]
WARNING: Visible dans `ps aux` et historique shell !

[.notes]
--
**VARIABLES D'ENVIRONNEMENT SHELL**

Qu'est-ce que c'est ?
- Passer les secrets via variables d'environnement du shell au lancement
- Les secrets restent en mÃ©moire du processus shell
- MÃ©thode la plus simple, mais limitations importantes

**Avantages :**
âœ… TrÃ¨s simple, pas de fichier .env Ã  gÃ©rer
âœ… Secrets restent dans la session shell (pas versionnÃ©s)
âœ… Utile pour CI/CD (GitLab CI, GitHub Actions injectent des variables)
âœ… Pas de dÃ©pendance externe
âœ… IdÃ©al pour scripts one-shot

**InconvÃ©nients :**
âŒ Visible dans `ps aux` (autres utilisateurs de la machine peuvent voir)
âŒ Reste dans l'historique shell (~/.bash_history) si export
âŒ Moins pratique pour plusieurs secrets (commande trÃ¨s longue)
âŒ Perd les secrets si session shell se ferme (pas persistant)
âŒ Difficile Ã  gÃ©rer en Ã©quipe (chacun doit set ses variables)

**Exemples d'utilisation :**

```bash
# MÃ©thode 1 : Inline (prÃ©fÃ©rable)
DB_PASSWORD="secret123" REDIS_PASSWORD="abc456" docker compose up -d

# MÃ©thode 2 : Export (reste en mÃ©moire shell)
export DB_PASSWORD="secret123"
export REDIS_PASSWORD="abc456"
docker compose up -d

# MÃ©thode 3 : Depuis fichier non versionnÃ©
source ~/secrets.sh  # contient les exports
docker compose up -d

# MÃ©thode 4 : CI/CD (GitLab CI exemple)
# Les variables sont injectÃ©es par le runner
script:
  - docker compose up -d  # $DB_PASSWORD dÃ©jÃ  disponible
```

**ProblÃ¨me de sÃ©curitÃ© - ps aux :**

```bash
# Autre utilisateur peut voir :
ps aux | grep docker
# user  1234  ... docker compose up -d  # DB_PASSWORD=secret123 visible !
```

**Quand l'utiliser :**
- DÃ©veloppement local rapide (test ponctuel)
- CI/CD pipelines (GitLab CI, GitHub Actions, Jenkins)
  - Les secrets sont injectÃ©s par le systÃ¨me CI/CD
  - Ne restent pas dans l'historique du runner
- Scripts d'automatisation ponctuels
- Environnements Ã©phÃ©mÃ¨res (conteneurs CI qui sont dÃ©truits aprÃ¨s)

**Quand NE PAS l'utiliser :**
- Production (trop risquÃ©, pas d'audit)
- Serveurs partagÃ©s (autres users peuvent voir)
- Secrets critiques (passwords DB prod, API keys sensibles)

**Pour SecureVote :**
Acceptable pour tests locaux rapides. Mais prÃ©fÃ©rer .env pour le TP (plus pÃ©dagogique, plus rÃ©aliste).
CI/CD bonus : montrer comment GitLab CI/GitHub Actions injectent les secrets.
--

== Comparaison des solutions

[cols="1,1,1,2", options="header"]
|===
|Solution |ComplexitÃ© |CoÃ»t |Cas d'usage

|Fichiers .env
|âšª Faible
|ğŸ’° Gratuit
|Dev, petits projets

|Docker Secrets
|ğŸŸ¡ Moyenne
|ğŸ’° Gratuit
|Docker Swarm prod

|Vault
|ğŸ”´ Ã‰levÃ©e
|ğŸ’°ğŸ’° Variable
|Grandes organisations

|Cloud Secrets
|ğŸŸ¡ Moyenne
|ğŸ’°ğŸ’° Payant
|DÃ©jÃ  sur cloud

|Variables shell
|âšª Faible
|ğŸ’° Gratuit
|Dev local, CI/CD
|===

[.notes]
--
**GUIDE DE DÃ‰CISION - Quelle solution choisir ?**

**Arbre de dÃ©cision simple :**

1. **Vous Ãªtes en dÃ©veloppement local ?**
   â†’ Fichiers .env (simple, rapide)

2. **Vous Ãªtes en production avec Docker Swarm ?**
   â†’ Docker Secrets (natif, cryptÃ©, gratuit)

3. **Vous Ãªtes sur AWS/Azure/GCP ?**
   â†’ Cloud Secrets Manager (managÃ©, intÃ©gration native)

4. **Vous avez 100+ secrets, multi-cloud, compliance stricte ?**
   â†’ Vault (solution complÃ¨te mais complexe)

5. **Vous Ãªtes en CI/CD ?**
   â†’ Variables shell (injectÃ©es par le pipeline)

**Ã‰volution typique d'une startup :**

Phase 1 (MVP) : .env files
- Simple, rapide Ã  mettre en place
- OK pour 5-10 secrets

Phase 2 (Croissance) : Cloud Secrets Manager
- Migration vers AWS/Azure/GCP
- 20-50 secrets
- Besoin de rotation automatique pour RDS

Phase 3 (Scale-up) : Vault
- Multi-cloud (AWS + GCP)
- 100+ secrets
- Ã‰quipe sÃ©curitÃ© dÃ©diÃ©e
- Compliance SOC2/ISO27001

**MESSAGE CLÃ‰ POUR LES Ã‰TUDIANTS :**

"Commencez simple avec .env, mais pensez dÃ©jÃ  Ã  l'Ã©chelle.
Si vous rejoignez une entreprise avec 500 microservices, vous utiliserez Vault ou cloud secrets.
Le principe reste le mÃªme : JAMAIS de secrets en clair dans Git !"

**POUR LE TP SECUREVOTE :**
- On utilise .env (pÃ©dagogique, simple)
- Discussion bonus : "Et si SecureVote devenait le prochain Doodle, avec 10M d'utilisateurs ?"
  â†’ Besoin de Vault ou AWS Secrets Manager
- Exercice bonus si temps : migrer vers Docker Secrets (Phase 3+)
--

[background-color="DarkOrange"]
== Phase 2 : SÃ©curisation (1h15)

Transformer SecureVote en application sÃ©curisÃ©e

[%step]
* Images sÃ»res et lÃ©gÃ¨res
* Scanner les vulnÃ©rabilitÃ©s avec Trivy
* Utilisateurs non-root
* ProtÃ©ger les secrets
* Isoler les rÃ©seaux

[.notes]
--
Phase la plus longue et la plus importante : 1h15 de pratique intensive.
Les Ã©tudiants doivent appliquer CONCRÃˆTEMENT tout ce qui vient d'Ãªtre vu.
RecommandÃ© : travail en binÃ´me pour favoriser l'entraide.
Circuler activement : c'est ici qu'ils vont bloquer.
Checkpoints rÃ©guliers toutes les 20-25 min pour synchroniser le groupe.
Objectif : phase1/ ne doit PLUS Ãªtre utilisÃ©e, tout le monde sur phase2/.
--

== Exercice 1 : Images sÃ©curisÃ©es (20 min)

**Mission :**

[%step]
. Scanner les images avec Docker Scout ou Trivy
. Identifier les vulnÃ©rabilitÃ©s critiques
. Remplacer par des images `-slim` ou `-alpine`
. Re-scanner et comparer

[source,bash]
----
docker scout cves securevote-backend:latest
# Modifier Dockerfile â†’ python:3.11-slim
docker compose build backend
docker scout cves securevote-backend:latest
----

[.notes]
--
Premier exercice : relativement simple pour mettre en confiance.
RÃ©sultat attendu : python:3.11 (150+ CVE) â†’ python:3.11-slim (20-30 CVE) = 80-90% de rÃ©duction.
Pour Node : node:20 â†’ node:20-alpine = encore plus spectaculaire.
PiÃ¨ge frÃ©quent : oublier de rebuild aprÃ¨s modification = image non scannÃ©e.
Attention : alpine peut casser certaines dÃ©pendances (musl vs glibc) â†’ prÃ©fÃ©rer slim si problÃ¨me.
Montrer que le fichier phase2/INSTRUCTIONS.md contient des indices.
--

== Exercice 2 : Utilisateurs non-root (25 min)

**Mission :**

Modifier tous les Dockerfiles pour des utilisateurs non-root

[%step]
. Backend Python : crÃ©er `flaskuser`
. Frontend React : crÃ©er `reactuser`
. Nginx : utiliser `nginx-unprivileged`

[source,dockerfile]
----
FROM python:3.11-slim
RUN groupadd -r flaskuser && useradd -r -g flaskuser flaskuser
USER flaskuser
----

== VÃ©rification utilisateurs

[source,bash]
----
docker compose exec backend ps aux
# Le processus principal (PID 1) doit tourner en tant que flaskuser

docker compose exec frontend ps aux
# Le processus principal (PID 1) doit tourner en tant que reactuser
----

TIP: Si vous voyez UID 0 ou `root` pour le processus principal, c'est Ã  corriger !

== Exercice 3 : SÃ©curiser les secrets (30 min)

**Mission :**

[%step]
. Identifier les secrets en clair dans docker-compose.yml
. CrÃ©er `.env` (sans le commiter !)
. Ajouter `.env` au `.gitignore`
. Utiliser les variables : `${DB_PASSWORD}`
. CrÃ©er `.env.example` comme template

== Checkpoint Phase 2

VÃ©rification collective :

[%step]
* Scans : moins de vulnÃ©rabilitÃ©s ?
* Aucun conteneur en root ?
* Aucun secret en clair versionnÃ© ?
* Application fonctionne ?

[source,bash]
----
docker compose ps
docker compose exec backend ps aux
trivy image securevote-backend:latest --severity HIGH,CRITICAL
----

[background-color="DarkGreen"]
== Configuration Production

[.columns]
====
[.column]
--
**DÃ©veloppement :**

* Ressources illimitÃ©es
* Logs verbeux
* RedÃ©marrages manuels
--

[.column]
--
**Production :**

* Ressources limitÃ©es
* Logs structurÃ©s
* Auto-healing
--
====

[.notes]
--
Transition importante : Phase 2 = sÃ©curitÃ©, Phase 3 = production/fiabilitÃ©.
En dev : on se fiche des ressources, on veut du confort (logs dÃ©taillÃ©s, restart manuel).
En prod : on veut de la STABILITÃ‰, de la PRÃ‰VISIBILITÃ‰, de l'AUTO-RÃ‰PARATION.
Analogie : dev = voiture de test, prod = avion de ligne (systÃ¨mes redondants, monitoring constant).
Ces deux aspects (sÃ©curitÃ© + prod) sont complÃ©mentaires et indissociables.
--

== Limites de ressources

**Pourquoi limiter ?**

[%step]
* EmpÃªcher monopolisation du serveur
* Garantir stabilitÃ©
* PrÃ©voir capacitÃ©
* DÃ©tecter fuites mÃ©moire

WARNING: Sans limites â†’ 100% CPU/RAM !

[.notes]
--
Histoire rÃ©elle : un conteneur mal configurÃ© monopolise 100% CPU d'un serveur = TOUS les autres services ralentissent.
Sans limites, Docker ne protÃ¨ge PAS : un conteneur peut tuer le serveur hÃ´te.
Les limites permettent de PLANIFIER : "j'ai 16 Go, je peux faire tourner 10 conteneurs Ã  1.5 Go chacun".
Les limites rÃ©vÃ¨lent les fuites mÃ©moire : si votre app atteint systÃ©matiquement la limite, elle fuit.
En prod, TOUJOURS dÃ©finir des limites. C'est comme les ceintures de sÃ©curitÃ© : obligatoire.
--

== DÃ©finir les limites

[source,yaml]
----
services:
  backend:
    deploy:
      resources:
        limits:
          cpus: '0.5'      # Max 50% CPU
          memory: 512M     # Max 512 Mo RAM
        reservations:
          cpus: '0.25'     # Min garanti
          memory: 256M
----

== Choisir les bonnes valeurs

[%step]
. DÃ©marrer sans limites
. Observer : `docker stats`
. Ajouter 20-30% de marge
. Tester sous charge
. Ajuster

== Politiques de redÃ©marrage

[source,yaml]
----
services:
  backend:
    restart: no              # Jamais
    restart: always          # Toujours
    restart: on-failure      # Si erreur
    restart: unless-stopped  # Sauf arrÃªt manuel
----

[%step]
**Production :** PrivilÃ©gier `unless-stopped` ou `on-failure`

== Restart avec limite

[source,yaml]
----
services:
  backend:
    restart: on-failure
----

NOTE: Pour limiter le nombre de tentatives en Docker Swarm, utilisez `deploy.restart_policy.max_attempts: 5`

Ã‰vite les boucles infinies de redÃ©marrage

== Health checks

[source,yaml]
----
services:
  backend:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
----

[.notes]
--
Health check = le contrÃ´le aÃ©rien de vos conteneurs.
Un conteneur peut Ãªtre "running" mais MORT Ã  l'intÃ©rieur (app crashÃ©e, connexion DB perdue).
docker ps montre "Up" mais healthcheck montre "unhealthy" = problÃ¨me dÃ©tectÃ© !
Exemple concret : backend dÃ©marre en 5s, mais connexion DB prend 30s â†’ start_period: 40s.
interval: 30s = vÃ©rifier toutes les 30s, c'est raisonnable (pas trop frÃ©quent, pas trop lent).
retries: 3 = tolÃ©rer 3 Ã©checs avant de marquer "unhealthy" = Ã©vite les faux positifs.
Le healthcheck doit Ãªtre RAPIDE (<1s) et LÃ‰GER (pas de requÃªtes DB lourdes).
--

== Endpoint de santÃ©

[source,python]
----
@app.route('/health')
def health():
    try:
        db.ping()
        return jsonify({"status": "healthy"}), 200
    except:
        return jsonify({"status": "unhealthy"}), 503
----

== DÃ©pendances entre services

[source,yaml]
----
services:
  backend:
    depends_on:
      database:
        condition: service_healthy
      cache:
        condition: service_started
----

[%step]
* `service_started` : DÃ©marrÃ© (pas forcÃ©ment prÃªt)
* `service_healthy` : Healthcheck validÃ©
* `service_completed_successfully` : TerminÃ© avec succÃ¨s

== Monitoring et logs

**ObservabilitÃ© :**

[%step]
* **Logs** : Que s'est-il passÃ© ?
* **MÃ©triques** : Combien de CPU/RAM/requÃªtes ?
* **Traces** : Quel chemin a pris une requÃªte ?

TIP: TP13 a dÃ©jÃ  couvert ELK

== Driver de logs

[source,yaml]
----
services:
  backend:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"      # Max 10 Mo
        max-file: "3"        # Garder 3 fichiers
----

WARNING: Sans limites, les logs remplissent le disque !

== Logs structurÃ©s

**Mauvais :** `Server started on port 5000`

**Bon :**

[source,json]
----
{"timestamp":"2025-01-15T10:30:00Z","level":"INFO","service":"backend","message":"Server started","port":5000}
----

[%step]
Facilement parsables par ELK, Loki, etc.

[background-color="ForestGreen"]
== Phase 3 : Production (1h)

Optimiser SecureVote pour la production

[%step]
* Limites de ressources
* Politiques de redÃ©marrage
* Health checks
* Optimiser les logs
* Tester la rÃ©silience

[.notes]
--
Phase finale : transformation en app production-ready.
Les Ã©tudiants ont maintenant une app SÃ‰CURISÃ‰E (Phase 2), ils vont la rendre FIABLE.
Cette phase inclut des TESTS de rÃ©silience : tuer des conteneurs, faire du load testing.
C'est ici qu'on voit si l'auto-healing fonctionne vraiment !
Les scripts load_test.sh et kill_test.sh sont fournis dans phase3/scripts/.
Encourager l'expÃ©rimentation : "cassez votre app volontairement pour voir ce qui se passe".
Temps : 1h = 3 exercices de 15-25 min chacun + checkpoint final.
--

== Exercice 4 : Limites de ressources (20 min)

**Mission :**

[%step]
. Observer avec `docker stats`
. DÃ©finir limites appropriÃ©es
. Tester sous charge (script fourni)
. Ajuster

[source,bash]
----
docker stats --no-stream
./load_test.sh
docker stats
----

== Exercice 5 : Restart et Health (25 min)

**Mission :**

[%step]
. Ajouter politiques de redÃ©marrage
. CrÃ©er endpoint `/health` dans backend
. Configurer healthchecks
. Tester en tuant un conteneur

[source,bash]
----
docker compose kill backend
docker compose ps
docker compose logs backend
----

== Exercice 6 : DÃ©pendances (15 min)

**Mission :**

[%step]
. Configurer `depends_on` avec conditions
. Tester ordre de dÃ©marrage
. Simuler indisponibilitÃ© DB
. VÃ©rifier backend ne dÃ©marre pas sans DB

== Checkpoint Phase 3

Application production-ready :

[%step]
* Limites de ressources âœ…
* Auto-healing âœ…
* Health checks âœ…
* DÃ©pendances ordonnÃ©es âœ…
* Logs optimisÃ©s âœ…

[source,bash]
----
docker compose config --services
docker compose ps
docker stats --no-stream
----

[background-color="Navy"]
== Registres et Distribution

[%step]
* Serveur de stockage d'images Docker
* Ã‰quivalent de npm pour Node, PyPI pour Python
* Public (Docker Hub) ou privÃ© (self-hosted)
* Gestion des versions (tags)

== Docker Hub

[source,bash]
----
docker pull nginx:latest
# Ã‰quivalent Ã  :
docker pull docker.io/library/nginx:latest
----

[%step]
* Gratuit pour images publiques
* Limites de rate (pull anonyme)

== Registres privÃ©s

**Pourquoi ?**

[%step]
* Images propriÃ©taires
* ContrÃ´le d'accÃ¨s
* Compliance et sÃ©curitÃ©
* Pas de limite de rate

== Solutions de registres

[%step]
* **Docker Registry** (open source)
* **Harbor** (CNCF, avec scan)
* **AWS ECR**, **Azure ACR**, **GCP GCR**
* **GitLab / GitHub Container Registry**

== DÃ©marrer un registre local

[source,bash]
----
docker run -d -p 5000:5000 --name registry registry:2
docker tag securevote-backend:latest localhost:5000/securevote-backend:latest
docker push localhost:5000/securevote-backend:latest
----

== Tags et versions

[source,bash]
----
# Bonne pratique : versionner
docker tag myapp:latest myregistry.com/myapp:1.2.3
docker tag myapp:latest myregistry.com/myapp:1.2
docker tag myapp:latest myregistry.com/myapp:latest
----

TIP: Plusieurs tags â†’ mÃªme image

== Exercice 7 : Registre local (Bonus)

**Si le temps le permet :**

[%step]
. DÃ©marrer registre local (port 5000)
. Tagger images SecureVote
. Pousser vers registre
. Modifier docker-compose.yml
. Re-dÃ©ployer

[background-color="MediumBlue"]
== RÃ©capitulatif et bonnes pratiques

== Checklist sÃ©curitÃ©

[%step]
* âœ… Images officielles et Ã  jour
* âœ… Scan rÃ©gulier des vulnÃ©rabilitÃ©s
* âœ… Utilisateurs non-root systÃ©matiques
* âœ… Secrets jamais en clair
* âœ… RÃ©seau isolÃ© par dÃ©faut

== Checklist production

[%step]
* âœ… Limites de ressources CPU/RAM
* âœ… Politiques de redÃ©marrage
* âœ… Health checks implÃ©mentÃ©s
* âœ… DÃ©pendances ordonnÃ©es
* âœ… Logs structurÃ©s et rotation

== Ce qu'on a appris

[%step]
* SÃ©curiser une application Docker de bout en bout
* Scanner et corriger les vulnÃ©rabilitÃ©s
* GÃ©rer les secrets correctement
* Configurer pour la production
* Distribuer via registres

== SecureVote : Avant/AprÃ¨s

[.columns]
====
[.column]
--
**Avant :**

* Images non scannÃ©es
* Root partout
* Secrets en clair
* Pas de limites
--

[.column]
--
**AprÃ¨s :**

* Images slim, scannÃ©es
* Utilisateurs dÃ©diÃ©s
* Secrets protÃ©gÃ©s
* Production-ready âœ…
--
====

== Aller plus loin

[%step]
* **Orchestration** : Kubernetes, Docker Swarm
* **Secrets Management** : Vault, Sealed Secrets
* **Image Signing** : Docker Content Trust, Cosign
* **Runtime Security** : Falco, Aqua Security

== Ressources utiles

* Docker Security: https://docs.docker.com/engine/security/
* CIS Docker Benchmark
* Trivy: https://github.com/aquasecurity/trivy
* OWASP Docker Security Cheat Sheet

[{invert}]
== Fin de la session

Bravo, vous avez transformÃ© SecureVote en application sÃ©curisÃ©e et production-ready !

[.notes]
--
Questions et discussion finale
Retours sur expÃ©rience
DifficultÃ©s rencontrÃ©es
--

== Questions ?

image::questions-docker.png[height=400px]

{author_mail}
